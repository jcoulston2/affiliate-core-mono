{"ast":null,"code":"import _defineProperty from \"/Users/justincoulston/Desktop/affilaite-core-mono/node_modules/next/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _toConsumableArray from \"/Users/justincoulston/Desktop/affilaite-core-mono/node_modules/next/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport { srcToHttp, getSingle, toArray } from '@helpers/common';\nimport { formatDistance } from 'date-fns';\nexport function hasValidTabbedData(data, isDefault) {\n  return !!isDefault || data.filter(function (isNull) {\n    return !isNull;\n  }).length !== data.length;\n}\nexport function mapCustomDataToTabs(customDescriptiveData) {\n  return customDescriptiveData.map(function (item) {\n    return {\n      title: item.customText,\n      data: item.data.map(function (notNull) {\n        return notNull;\n      })\n    };\n  });\n}\nexport function normalizeSingleImage(src, domain) {\n  var toHttp = srcToHttp(src);\n  return toHttp.startsWith('/') ? domain + src : toHttp;\n}\nexport function reduceDuplicateUrls(urls) {\n  return urls.reduce(function (acc, cur) {\n    var includesBaseUrl = acc.some(function (checkedUrl) {\n      var params = new URL(cur);\n      var query = params.search;\n      var base = cur.replace(query, '');\n      return checkedUrl.includes(base);\n    });\n    return includesBaseUrl ? acc : [].concat(_toConsumableArray(acc), [cur]);\n  }, []);\n}\nexport function hasRequiredProductInformation(_ref) {\n  var detailedData = _ref.detailedData,\n      topLevelData = _ref.topLevelData,\n      metaData = _ref.metaData;\n  return !!(detailedData && topLevelData && metaData);\n}\nexport function normalizeTopLevelProductData(data) {\n  var normalized = Object.keys(data).reduce(function (accum, cur) {\n    return _objectSpread(_objectSpread({}, accum), {}, _defineProperty({}, cur, Array.isArray(data[cur]) ? data[cur][0] : data[cur]));\n  }, {});\n  return normalized;\n} // Although rare, there may be some cases where we always want to return a single value\n// instead of an array of values. This helper function just provides an extra security layer\n// incase we have accidentally defined a selector which picks up multiple values\n\nexport function normalizeDetailProductData(data) {\n  var normalized = {};\n  Object.keys(data).forEach(function (detailDataKey) {\n    var detailDataValue = data[detailDataKey];\n\n    switch (detailDataKey) {\n      case 'selectedColor':\n        normalized[detailDataKey] = getSingle(detailDataValue);\n        break;\n      // we can skip custom and variants as they are special cases\n\n      case 'variants':\n      case 'custom':\n        normalized[detailDataKey] = detailDataValue;\n        break;\n\n      default:\n        normalized[detailDataKey] = toArray(detailDataValue);\n        break;\n    }\n  });\n  return normalized;\n}\nexport function getCustomDescriptiveData(customData) {\n  return (customData === null || customData === void 0 ? void 0 : customData.filter(function (customDataItem) {\n    return customDataItem.data.some(function (dataItem) {\n      return dataItem.isDescriptive;\n    });\n  })) || [];\n}\nexport function getCustomPrimaryData(customData) {\n  return (customData === null || customData === void 0 ? void 0 : customData.filter(function (customDataItem) {\n    return customDataItem.data.some(function (dataItem) {\n      return dataItem.isPrimary;\n    });\n  }).map(function (item) {\n    return _objectSpread(_objectSpread({}, item), {}, {\n      variantText: item.customText\n    });\n  })) || [];\n}\nexport function getPriceLastUpdated(categoryLastUpdated) {\n  var lastUpdated = categoryLastUpdated ? formatDistance(new Date(categoryLastUpdated), new Date(), {\n    addSuffix: true\n  }) : null;\n  var tooLongThreshold = lastUpdated && /year|month/.test(lastUpdated);\n  return tooLongThreshold ? null : lastUpdated;\n} // TODO: the below logic should really be removed from core, since the logic exists in the extractor service,\n// we just need to remember to add the \"omitDuplicateImgByBase\" when defening schemas for brands that pick up\n// multiple differing quality params! Or we should set omitDuplicateImgByBase to true by default. See the\n// extractor service for more details\n\nvar validatedImages = [];\nexport function isDuplicateImg(src, omitDuplicateImgByBase) {\n  var isDuplicate;\n  if (!src) return false;\n\n  if (omitDuplicateImgByBase) {\n    var params = new URL(src);\n    var query = params.search;\n    var base = src.replace(query, '');\n    isDuplicate = validatedImages.includes(base);\n    if (!isDuplicate) validatedImages.push(base);\n  } else {\n    isDuplicate = validatedImages.includes(src);\n    if (!isDuplicate) validatedImages.push(src);\n  }\n\n  return isDuplicate;\n} // TODO: see above comment\n\nexport function getValidImages(images) {\n  validatedImages = [];\n  return images.filter(function (img) {\n    return !isDuplicateImg(img, true);\n  });\n}","map":null,"metadata":{},"sourceType":"module"}