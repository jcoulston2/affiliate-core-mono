{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport { deDupeArray, urlCase } from '@helpers/common';\nimport { SEARCH_PATH } from '@constants';\nexport function addUrlPart(name, value, partsArray) {\n  // remove any existing params for a given name to be overwritten\n  const parts = partsArray.filter(item => item && !item.includes(name));\n  parts.push(`${name}=${value}`);\n  return parts;\n}\nexport function addExistingUrlParts(productUrl, productUrlParams) {\n  if (!productUrl) return [];\n  const query = productUrlParams === null || productUrlParams === void 0 ? void 0 : productUrlParams.search;\n  return (query === null || query === void 0 ? void 0 : query.replace(/^\\?/, '').split('&')) || [];\n}\nexport function createUrlFilters({\n  priceSort,\n  priceThresholdLow,\n  priceThresholdHigh,\n  keyWords,\n  saleThreshold,\n  brands,\n  section,\n  category\n}, productUrl, isSearchPage) {\n  const origin = window.location.origin;\n  const productUrlParams = new URL(`${origin}${productUrl}`);\n  const productUrlPath = productUrlParams.pathname;\n  const queryJoiner = isSearchPage ? '?' : '';\n  let urlParts = addExistingUrlParts(productUrl, productUrlParams);\n\n  if (priceSort) {\n    urlParts = addUrlPart('price-sort', priceSort, urlParts);\n  }\n\n  if (priceThresholdLow) {\n    urlParts = addUrlPart('price-threshold-low', priceThresholdLow, urlParts);\n  }\n\n  if (priceThresholdHigh) {\n    urlParts = addUrlPart('price-threshold-high', priceThresholdHigh, urlParts);\n  }\n\n  if (keyWords !== null && keyWords !== void 0 && keyWords.length) {\n    urlParts = addUrlPart('key-words', keyWords.join(','), urlParts);\n  }\n\n  if (brands !== null && brands !== void 0 && brands.length) {\n    urlParts = addUrlPart('brands', brands.join(','), urlParts);\n  }\n\n  if (saleThreshold && parseInt(saleThreshold)) {\n    urlParts = addUrlPart('sale-threshold', saleThreshold, urlParts);\n  }\n\n  if (category !== null && category !== void 0 && category.length) {\n    urlParts = addUrlPart('category', category.join(','), urlParts);\n  }\n\n  if (section) {\n    urlParts = addUrlPart('section', section, urlParts);\n  }\n\n  const filterPath = urlParts.length ? `${urlParts.join('&')}` : '';\n  window.history.replaceState({}, null, `${productUrlPath}${queryJoiner}${filterPath}`);\n}\nexport function normalizeFilters({\n  priceSort,\n  priceThreshold,\n  keyWords,\n  saleThreshold,\n  scaler,\n  hasTouchedSlider,\n  brands,\n  section,\n  category\n}, isSearchPage) {\n  const [min, max] = priceThreshold;\n  const isMinSetting = min === 0;\n  const isMaxSetting = max === 100;\n  const minPrice = hasTouchedSlider && !isMinSetting ? min * scaler : null;\n  const maxPrice = hasTouchedSlider && !isMaxSetting ? max * scaler : null;\n  const searchSpecificFilters = isSearchPage ? {\n    section,\n    category: category !== null && category !== void 0 && category.length ? category : null\n  } : {};\n  return _objectSpread({\n    priceThresholdLow: minPrice,\n    priceThresholdHigh: maxPrice,\n    priceSort: priceSort === 'recommended' ? null : priceSort,\n    keyWords: keyWords !== null && keyWords !== void 0 && keyWords.length ? keyWords : null,\n    brands: brands !== null && brands !== void 0 && brands.length ? brands : null,\n    saleThreshold: parseInt(saleThreshold)\n  }, searchSpecificFilters);\n}\nexport function getNumberOfFiltersSelected(filters) {\n  return Object.keys(filters).filter(key => {\n    const filterValue = filters[key];\n    return !!filterValue && filterValue !== 'recommended';\n  }).length;\n} // TODO: this helper is not fully \"white labeled\" given we are looking at the first item in the \"subNav\"\n// array. For different \"labels\", this will have to be rewritten\n\nexport function getCategoryFilters(section, categoryData) {\n  if (!categoryData) return [];\n\n  if (section) {\n    var _sectionData$subNav$;\n\n    const sectionData = categoryData.find(sec => sec.title === section);\n    return (sectionData === null || sectionData === void 0 ? void 0 : (_sectionData$subNav$ = sectionData.subNav[0]) === null || _sectionData$subNav$ === void 0 ? void 0 : _sectionData$subNav$.subNavItems.map(item => item.title)) || [];\n  } else {\n    const allItems = categoryData === null || categoryData === void 0 ? void 0 : categoryData.map(sec => {\n      var _sec$subNav$;\n\n      return (sec === null || sec === void 0 ? void 0 : sec.subNav) && (sec === null || sec === void 0 ? void 0 : (_sec$subNav$ = sec.subNav[0]) === null || _sec$subNav$ === void 0 ? void 0 : _sec$subNav$.subNavItems.map(item => item.title));\n    });\n    return deDupeArray((allItems === null || allItems === void 0 ? void 0 : allItems.flat()) || []);\n  }\n}\nexport function getSectionFilters(section, categoryData) {\n  return (categoryData === null || categoryData === void 0 ? void 0 : categoryData.map(sec => sec.title)) || [];\n}\nexport function sortSelectedCheckboxes(fullList, selectedList) {\n  return fullList.sort(item => {\n    if (selectedList.includes(urlCase(item))) {\n      return -1;\n    }\n  });\n}\nexport function isSearch(router) {\n  return router.pathname.includes(SEARCH_PATH);\n}","map":null,"metadata":{},"sourceType":"module"}