{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport { srcToHttp, getSingle, toArray } from '@helpers/common';\nimport { formatDistance } from 'date-fns';\nexport function hasValidTabbedData(data, isDefault) {\n  return !!isDefault || data.filter(isNull => !isNull).length !== data.length;\n}\nexport function mapCustomDataToTabs(customDescriptiveData) {\n  return customDescriptiveData.map(item => ({\n    title: item.customText,\n    data: item.data.map(notNull => notNull)\n  }));\n}\nexport function normalizeSingleImage(src, domain) {\n  const toHttp = srcToHttp(src);\n  return toHttp.startsWith('/') ? domain + src : toHttp;\n}\nexport function reduceDuplicateUrls(urls) {\n  return urls.reduce((acc, cur) => {\n    const includesBaseUrl = acc.some(checkedUrl => {\n      const params = new URL(cur);\n      const query = params.search;\n      const base = cur.replace(query, '');\n      return checkedUrl.includes(base);\n    });\n    return includesBaseUrl ? acc : [...acc, cur];\n  }, []);\n}\nexport function hasRequiredProductInformation({\n  detailedData,\n  topLevelData,\n  metaData\n}) {\n  return !!(detailedData && topLevelData && metaData);\n}\nexport function normalizeTopLevelProductData(data) {\n  const normalized = Object.keys(data).reduce((accum, cur) => {\n    return _objectSpread(_objectSpread({}, accum), {}, {\n      [cur]: Array.isArray(data[cur]) ? data[cur][0] : data[cur]\n    });\n  }, {});\n  return normalized;\n} // Although rare, there may be some cases where we always want to return a single value\n// instead of an array of values. This helper function just provides an extra security layer\n// incase we have accidentally defined a selector which picks up multiple values\n\nexport function normalizeDetailProductData(data) {\n  let normalized = {};\n  Object.keys(data).forEach(detailDataKey => {\n    const detailDataValue = data[detailDataKey];\n\n    switch (detailDataKey) {\n      case 'selectedColor':\n        normalized[detailDataKey] = getSingle(detailDataValue);\n        break;\n      // we can skip custom and variants as they are special cases\n\n      case 'variants':\n      case 'custom':\n        normalized[detailDataKey] = detailDataValue;\n        break;\n\n      default:\n        normalized[detailDataKey] = toArray(detailDataValue);\n        break;\n    }\n  });\n  return normalized;\n}\nexport function getCustomDescriptiveData(customData) {\n  return (customData === null || customData === void 0 ? void 0 : customData.filter(customDataItem => customDataItem.data.some(dataItem => dataItem.isDescriptive))) || [];\n}\nexport function getCustomPrimaryData(customData) {\n  return (customData === null || customData === void 0 ? void 0 : customData.filter(customDataItem => customDataItem.data.some(dataItem => dataItem.isPrimary)).map(item => _objectSpread(_objectSpread({}, item), {}, {\n    variantText: item.customText\n  }))) || [];\n}\nexport function getPriceLastUpdated(categoryLastUpdated) {\n  const lastUpdated = categoryLastUpdated ? formatDistance(new Date(categoryLastUpdated), new Date(), {\n    addSuffix: true\n  }) : null;\n  const tooLongThreshold = lastUpdated && /year|month/.test(lastUpdated);\n  return tooLongThreshold ? null : lastUpdated;\n} // TODO: the below logic should really be removed from core, since the logic exists in the extractor service,\n// we just need to remember to add the \"omitDuplicateImgByBase\" when defening schemas for brands that pick up\n// multiple differing quality params! Or we should set omitDuplicateImgByBase to true by default. See the\n// extractor service for more details\n\nlet validatedImages = [];\nexport function isDuplicateImg(src, omitDuplicateImgByBase) {\n  let isDuplicate;\n  if (!src) return false;\n\n  if (omitDuplicateImgByBase) {\n    const params = new URL(src);\n    const query = params.search;\n    const base = src.replace(query, '');\n    isDuplicate = validatedImages.includes(base);\n    if (!isDuplicate) validatedImages.push(base);\n  } else {\n    isDuplicate = validatedImages.includes(src);\n    if (!isDuplicate) validatedImages.push(src);\n  }\n\n  return isDuplicate;\n} // TODO: see above comment\n\nexport function getValidImages(images) {\n  validatedImages = [];\n  return images.filter(img => !isDuplicateImg(img, true));\n}","map":null,"metadata":{},"sourceType":"module"}