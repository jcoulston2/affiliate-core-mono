{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/extends\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nvar __jsx = React.createElement;\nimport React, { useEffect } from 'react';\nimport { getNode } from '@helpers/common';\nimport { FlickAnimationsProvider, FlickCard, FlickCardInner, CardContainer, AnimationContainer } from './styles';\nimport { selectors } from './helper';\n// IMPORTANT NOTE: normally handling logic via query selectors with React components does not sit well in most cases,\n// often this can lead to re-rendering confusion as well as convoluted logic. In the below, there are examples of using query\n// selectors - the reason for this is to make transitions as smooth as possible and to avoid 'glitching / jerking' caused by\n// component re-renders. The card animations are handled via an external library. Becasue we have so many product cards stacked\n// on top of each other with all their held product information, passing through a large data map of products causes some\n// performance issues as well as UX / UI issues. The library does not handle these performance issues and only works on a\n// card by card basis. Rather than rendering all the products, we only 'show' the relevant product when it's next in the list.\n// We do this via query selectors and CSS to make the transitions as smooth as possible.\nlet lastCardIndexSwiped = null;\nlet flickUrlTracker = null;\nexport default function Flicker(_ref) {\n  let {\n    dataMap,\n    Component,\n    onEndCallback,\n    onSwipeCallback,\n    SwipeIconUp,\n    SwipeIconDown,\n    SwipeIconLeft,\n    SwipeIconRight\n  } = _ref,\n      rest = _objectWithoutProperties(_ref, [\"dataMap\", \"Component\", \"onEndCallback\", \"onSwipeCallback\", \"SwipeIconUp\", \"SwipeIconDown\", \"SwipeIconLeft\", \"SwipeIconRight\"]);\n\n  const handleAnimationEffect = direction => {\n    var _getNode, _getNode2;\n\n    const animationContainerSelector = selectors.animationContainer();\n    const animationIcon = selectors.animationIcon(direction);\n    (_getNode = getNode(animationIcon)) === null || _getNode === void 0 ? void 0 : _getNode.classList.add('icon-show');\n    (_getNode2 = getNode(animationContainerSelector)) === null || _getNode2 === void 0 ? void 0 : _getNode2.classList.add('pulse');\n    setTimeout(() => {\n      var _getNode3, _getNode4;\n\n      (_getNode3 = getNode(animationIcon)) === null || _getNode3 === void 0 ? void 0 : _getNode3.classList.remove('icon-show');\n      (_getNode4 = getNode(animationContainerSelector)) === null || _getNode4 === void 0 ? void 0 : _getNode4.classList.remove('pulse');\n    }, 501);\n  };\n\n  const setLastCardIndexSwiped = index => {\n    lastCardIndexSwiped = index;\n  };\n\n  const getNodeByIndex = index => {\n    const selector = selectors.cardNode(index);\n    return getNode(selector);\n  };\n\n  const handleRevealCards = index => {\n    const revealCardNodes = getNodeByIndex(index);\n    if (revealCardNodes) revealCardNodes.style.display = 'block';\n  };\n\n  const resetCardIndex = () => {\n    lastCardIndexSwiped = null;\n  };\n\n  const setUrlTracker = plpUrl => {\n    flickUrlTracker = plpUrl;\n  };\n\n  const handleCardsReset = () => {\n    const plpUrl = window.location.href;\n\n    if (!flickUrlTracker) {\n      setUrlTracker(plpUrl);\n    } else if (plpUrl !== flickUrlTracker) {\n      resetCardIndex();\n      setUrlTracker(plpUrl);\n    }\n  };\n\n  const swiped = (direction, dataItem, index) => {\n    const nextCard = index + 1;\n\n    if (index >= dataMap.length && onEndCallback) {\n      return onEndCallback();\n    } else {\n      handleAnimationEffect(direction);\n      handleRevealCards(nextCard);\n      setLastCardIndexSwiped(nextCard);\n      onSwipeCallback(direction, dataItem);\n    }\n  };\n\n  useEffect(() => {\n    const nextCard = lastCardIndexSwiped + 1;\n    handleRevealCards(nextCard);\n  }, [dataMap.length]);\n  handleCardsReset();\n  return __jsx(CardContainer, {\n    \"data-ref\": \"card-container\"\n  }, dataMap.map((dataItem, index) => {\n    const nodeIndex = index + 1;\n    return __jsx(FlickCard, _extends({\n      key: index,\n      onSwipe: dir => swiped(dir, dataItem, nodeIndex),\n      preventSwipe: ['down']\n    }, rest), __jsx(FlickCardInner, null, __jsx(Component.type, _extends({}, Component.props, dataItem))));\n  }), __jsx(FlickAnimationsProvider, null), __jsx(AnimationContainer, {\n    \"data-ref\": \"animation-container\"\n  }, SwipeIconUp && __jsx(SwipeIconUp.type, _extends({}, SwipeIconUp.props, {\n    \"data-ref\": \"up\"\n  })), SwipeIconDown && __jsx(SwipeIconDown.type, _extends({}, SwipeIconDown.props, {\n    \"data-ref\": \"down\"\n  })), SwipeIconLeft && __jsx(SwipeIconLeft.type, _extends({}, SwipeIconLeft.props, {\n    \"data-ref\": \"left\"\n  })), SwipeIconRight && __jsx(SwipeIconRight.type, _extends({}, SwipeIconRight.props, {\n    \"data-ref\": \"right\"\n  }))));\n}","map":null,"metadata":{},"sourceType":"module"}