{"ast":null,"code":"import _extends from \"/Users/justincoulston/Desktop/affilaite-core-mono/node_modules/next/node_modules/@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutProperties from \"/Users/justincoulston/Desktop/affilaite-core-mono/node_modules/next/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties\";\nvar __jsx = React.createElement;\nimport React, { useEffect } from 'react';\nimport { getNode } from '@helpers/common';\nimport { FlickAnimationsProvider, FlickCard, FlickCardInner, CardContainer, AnimationContainer } from './styles';\nimport { selectors } from './helper';\n// IMPORTANT NOTE: normally handling logic via query selectors with React components does not sit well in most cases,\n// often this can lead to re-rendering confusion as well as convoluted logic. In the below, there are examples of using query\n// selectors - the reason for this is to make transitions as smooth as possible and to avoid 'glitching / jerking' caused by\n// component re-renders. The card animations are handled via an external library. Becasue we have so many product cards stacked\n// on top of each other with all their held product information, passing through a large data map of products causes some\n// performance issues as well as UX / UI issues. The library does not handle these performance issues and only works on a\n// card by card basis. Rather than rendering all the products, we only 'show' the relevant product when it's next in the list.\n// We do this via query selectors and CSS to make the transitions as smooth as possible.\nvar lastCardIndexSwiped = null;\nvar flickUrlTracker = null;\nexport default function Flicker(_ref) {\n  var dataMap = _ref.dataMap,\n      Component = _ref.Component,\n      onEndCallback = _ref.onEndCallback,\n      onSwipeCallback = _ref.onSwipeCallback,\n      SwipeIconUp = _ref.SwipeIconUp,\n      SwipeIconDown = _ref.SwipeIconDown,\n      SwipeIconLeft = _ref.SwipeIconLeft,\n      SwipeIconRight = _ref.SwipeIconRight,\n      rest = _objectWithoutProperties(_ref, [\"dataMap\", \"Component\", \"onEndCallback\", \"onSwipeCallback\", \"SwipeIconUp\", \"SwipeIconDown\", \"SwipeIconLeft\", \"SwipeIconRight\"]);\n\n  var handleAnimationEffect = function handleAnimationEffect(direction) {\n    var _getNode, _getNode2;\n\n    var animationContainerSelector = selectors.animationContainer();\n    var animationIcon = selectors.animationIcon(direction);\n    (_getNode = getNode(animationIcon)) === null || _getNode === void 0 ? void 0 : _getNode.classList.add('icon-show');\n    (_getNode2 = getNode(animationContainerSelector)) === null || _getNode2 === void 0 ? void 0 : _getNode2.classList.add('pulse');\n    setTimeout(function () {\n      var _getNode3, _getNode4;\n\n      (_getNode3 = getNode(animationIcon)) === null || _getNode3 === void 0 ? void 0 : _getNode3.classList.remove('icon-show');\n      (_getNode4 = getNode(animationContainerSelector)) === null || _getNode4 === void 0 ? void 0 : _getNode4.classList.remove('pulse');\n    }, 501);\n  };\n\n  var setLastCardIndexSwiped = function setLastCardIndexSwiped(index) {\n    lastCardIndexSwiped = index;\n  };\n\n  var getNodeByIndex = function getNodeByIndex(index) {\n    var selector = selectors.cardNode(index);\n    return getNode(selector);\n  };\n\n  var handleRevealCards = function handleRevealCards(index) {\n    var revealCardNodes = getNodeByIndex(index);\n    if (revealCardNodes) revealCardNodes.style.display = 'block';\n  };\n\n  var resetCardIndex = function resetCardIndex() {\n    lastCardIndexSwiped = null;\n  };\n\n  var setUrlTracker = function setUrlTracker(plpUrl) {\n    flickUrlTracker = plpUrl;\n  };\n\n  var handleCardsReset = function handleCardsReset() {\n    var plpUrl = window.location.href;\n\n    if (!flickUrlTracker) {\n      setUrlTracker(plpUrl);\n    } else if (plpUrl !== flickUrlTracker) {\n      resetCardIndex();\n      setUrlTracker(plpUrl);\n    }\n  };\n\n  var swiped = function swiped(direction, dataItem, index) {\n    var nextCard = index + 1;\n\n    if (index >= dataMap.length && onEndCallback) {\n      return onEndCallback();\n    } else {\n      handleAnimationEffect(direction);\n      handleRevealCards(nextCard);\n      setLastCardIndexSwiped(nextCard);\n      onSwipeCallback(direction, dataItem);\n    }\n  };\n\n  useEffect(function () {\n    var nextCard = lastCardIndexSwiped + 1;\n    handleRevealCards(nextCard);\n  }, [dataMap.length]);\n  handleCardsReset();\n  return __jsx(CardContainer, {\n    \"data-ref\": \"card-container\"\n  }, dataMap.map(function (dataItem, index) {\n    var nodeIndex = index + 1;\n    return __jsx(FlickCard, _extends({\n      key: index,\n      onSwipe: function onSwipe(dir) {\n        return swiped(dir, dataItem, nodeIndex);\n      },\n      preventSwipe: ['down']\n    }, rest), __jsx(FlickCardInner, null, __jsx(Component.type, _extends({}, Component.props, dataItem))));\n  }), __jsx(FlickAnimationsProvider, null), __jsx(AnimationContainer, {\n    \"data-ref\": \"animation-container\"\n  }, SwipeIconUp && __jsx(SwipeIconUp.type, _extends({}, SwipeIconUp.props, {\n    \"data-ref\": \"up\"\n  })), SwipeIconDown && __jsx(SwipeIconDown.type, _extends({}, SwipeIconDown.props, {\n    \"data-ref\": \"down\"\n  })), SwipeIconLeft && __jsx(SwipeIconLeft.type, _extends({}, SwipeIconLeft.props, {\n    \"data-ref\": \"left\"\n  })), SwipeIconRight && __jsx(SwipeIconRight.type, _extends({}, SwipeIconRight.props, {\n    \"data-ref\": \"right\"\n  }))));\n}","map":null,"metadata":{},"sourceType":"module"}