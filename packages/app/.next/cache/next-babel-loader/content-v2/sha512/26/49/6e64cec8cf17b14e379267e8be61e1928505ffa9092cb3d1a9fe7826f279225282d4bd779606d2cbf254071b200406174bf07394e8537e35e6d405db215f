{"ast":null,"code":"// TODO: we need to make the redis import work\n// import redis from 'redis';\nimport * as Promise from 'bluebird';\nimport { IS_PROD, IS_DEV } from '../../constants';\nimport storeCache from '../../__store-cache__/store-cache.json';\nimport { zipParse } from '../../helpers/common';\n\nclass Store {\n  // TODO: needs trimming\n  constructor(data, config = {}) {\n    this.store = data || null; // TODO: document but remove\n    // REDIS_PORT=19338\n    // REDIS_HOST=redis-19338.c8.us-east-1-2.ec2.cloud.redislabs.com\n    // REDIS_PASS=P9bI56wmohIikUs7ym3KRCtYAVvSOo8s\n    // REDIS_KEY=test\n\n    this.redisHost = '';\n    this.redisPort = '';\n    this.redisAuth = '';\n    this.redisKey = '';\n    this.redisRequireAuth = IS_PROD;\n\n    if (config.useRedis) {\n      this.redisClient = redis.createClient({\n        port: this.redisPort,\n        host: this.redisHost,\n        no_ready_check: true\n      });\n    }\n  }\n\n  listenToConnections() {\n    this.redisClient.on('connect', () => {\n      console.log(':::REDIS CLIENT CONNECTED:::');\n    });\n    this.redisClient.on('error', errpr => {\n      console.log(`:::REDIS ERROR::: ${errpr}`);\n    });\n  }\n\n  promisifyRedisMethods() {\n    const context = {\n      context: this.redisClient\n    };\n    this.redisClientAuthPromise = Promise.promisify(this.redisClient.auth, context);\n    this.redisFlushPromise = Promise.promisify(this.redisClient.del, context);\n    this.redisSetPromise = Promise.promisify(this.redisClient.set, context);\n    this.redisGetPromise = Promise.promisify(this.redisClient.get, context);\n  }\n\n  serialize(data) {\n    return JSON.stringify(data);\n  } // Attempts to build from Redis cloud, if there is no redis store, fallback to\n  // to pre-provided constructor value for store or else give an empty array\n\n\n  async buildStoreFromRedis() {\n    const redisStore = await this.redisGetPromise(this.redisKey);\n    this.store = redisStore ? JSON.parse(redisStore) : this.store || [];\n    return this.store;\n  }\n\n  async connectRedisClient() {\n    this.listenToConnections();\n    this.promisifyRedisMethods();\n    if (this.redisRequireAuth) await this.redisClientAuthPromise(this.redisAuth);\n    return await this.buildStoreFromRedis();\n  }\n\n  async flush() {\n    await this.redisFlushPromise(this.redisKey);\n    const checkFlushed = await this.redisGetPromise(this.redisKey);\n    if (!checkFlushed) console.log(`FLUSHED ${this.redisKey}`);\n  }\n\n  async setStore(affiliateData) {\n    this.store = affiliateData;\n\n    try {\n      if (this.redisClient) {\n        await this.redisSetPromise(this.redisKey, this.serialize(affiliateData));\n      }\n\n      return {\n        success: true\n      };\n    } catch (e) {\n      return {\n        success: false,\n        error: `${e}`\n      };\n    }\n  } // Redis only\n\n\n  async getRedisStore() {\n    const store = await this.redisGetPromise(this.redisKey);\n    return JSON.parse(store);\n  } // Redis only\n\n\n  getStore() {\n    return this.store;\n  }\n\n}\n\nconst configuredStore = new Store(zipParse(storeCache.store), {\n  useRedis: false\n});\nexport { configuredStore, Store };","map":{"version":3,"sources":["/Users/justincoulston/Desktop/affilaite-core-mono/packages/affiliate-app/server/store/Store.js"],"names":["Promise","IS_PROD","IS_DEV","storeCache","zipParse","Store","constructor","data","config","store","redisHost","redisPort","redisAuth","redisKey","redisRequireAuth","useRedis","redisClient","redis","createClient","port","host","no_ready_check","listenToConnections","on","console","log","errpr","promisifyRedisMethods","context","redisClientAuthPromise","promisify","auth","redisFlushPromise","del","redisSetPromise","set","redisGetPromise","get","serialize","JSON","stringify","buildStoreFromRedis","redisStore","parse","connectRedisClient","flush","checkFlushed","setStore","affiliateData","success","e","error","getRedisStore","getStore","configuredStore"],"mappings":"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","sourcesContent":["//@flow\n\n// TODO: we need to make the redis import work\n// import redis from 'redis';\nimport * as Promise from 'bluebird';\nimport { IS_PROD, IS_DEV } from '../../constants';\nimport storeCache from '../../__store-cache__/store-cache.json';\nimport { zipParse } from '../../helpers/common';\nimport { type ParsedStore, type SerializedStore } from '../../types/store';\n\n/**\n * @Info The Store class acts as an in memory storage cache and talks to the database. The logic when to\n * fetch the data from the DB lives here. Where possible, the storage is all in memory and when the extractor\n * service sends a routine payload of products, this is stored here as a cache, we also update the database.\n * The only time we fetch from the database is when the server starts / rebuilds, this prevents the data from\n * being lost every time the server is rebuilt.\n */\n\ntype StoreConfig = {\n  useRedis: boolean,\n};\n\nclass Store {\n  redisHost: string;\n  redisPort: string;\n  redisAuth: string;\n  redisKey: string;\n  redisRequireAuth: boolean;\n  redisClientAuthPromise: Function;\n  redisFlushPromise: Function;\n  redisSetPromise: Function;\n  redisGetPromise: Function;\n  redisClient: Object;\n  store: Array<any> | Object;\n\n  // TODO: needs trimming\n  constructor(data: any, config: StoreConfig = {}): void {\n    this.store = data || null;\n\n    // TODO: document but remove\n    // REDIS_PORT=19338\n    // REDIS_HOST=redis-19338.c8.us-east-1-2.ec2.cloud.redislabs.com\n    // REDIS_PASS=P9bI56wmohIikUs7ym3KRCtYAVvSOo8s\n    // REDIS_KEY=test\n    this.redisHost = '';\n    this.redisPort = '';\n    this.redisAuth = '';\n    this.redisKey = '';\n    this.redisRequireAuth = IS_PROD;\n\n    if (config.useRedis) {\n      this.redisClient = redis.createClient({\n        port: this.redisPort,\n        host: this.redisHost,\n        no_ready_check: true,\n      });\n    }\n  }\n\n  listenToConnections(): void {\n    this.redisClient.on('connect', () => {\n      console.log(':::REDIS CLIENT CONNECTED:::');\n    });\n    this.redisClient.on('error', (errpr) => {\n      console.log(`:::REDIS ERROR::: ${errpr}`);\n    });\n  }\n\n  promisifyRedisMethods(): void {\n    const context = {\n      context: this.redisClient,\n    };\n\n    this.redisClientAuthPromise = Promise.promisify(this.redisClient.auth, context);\n    this.redisFlushPromise = Promise.promisify(this.redisClient.del, context);\n    this.redisSetPromise = Promise.promisify(this.redisClient.set, context);\n    this.redisGetPromise = Promise.promisify(this.redisClient.get, context);\n  }\n\n  serialize(data: Object): string {\n    return JSON.stringify(data);\n  }\n\n  // Attempts to build from Redis cloud, if there is no redis store, fallback to\n  // to pre-provided constructor value for store or else give an empty array\n  async buildStoreFromRedis(): Promise<ParsedStore> {\n    const redisStore = await this.redisGetPromise<Promise<any>>(this.redisKey);\n    this.store = redisStore ? JSON.parse(redisStore) : this.store || [];\n    return this.store;\n  }\n\n  async connectRedisClient(): Promise<ParsedStore> {\n    this.listenToConnections();\n    this.promisifyRedisMethods();\n    if (this.redisRequireAuth) await this.redisClientAuthPromise<Promise<any>>(this.redisAuth);\n    return await this.buildStoreFromRedis();\n  }\n\n  async flush(): Promise<any> {\n    await this.redisFlushPromise(this.redisKey);\n    const checkFlushed = await this.redisGetPromise<Promise<any>>(this.redisKey);\n    if (!checkFlushed) console.log(`FLUSHED ${this.redisKey}`);\n  }\n\n  async setStore(\n    affiliateData: Array<any> | Object\n  ): Promise<{ success: boolean, error?: string }> {\n    this.store = affiliateData;\n\n    try {\n      if (this.redisClient) {\n        await this.redisSetPromise<Promise<any>>(this.redisKey, this.serialize(affiliateData));\n      }\n      return {\n        success: true,\n      };\n    } catch (e) {\n      return {\n        success: false,\n        error: `${e}`,\n      };\n    }\n  }\n\n  // Redis only\n  async getRedisStore(): Promise<ParsedStore> {\n    const store = await this.redisGetPromise<Promise<any>>(this.redisKey);\n    return JSON.parse(store);\n  }\n\n  // Redis only\n  getStore(): Promise<ParsedStore> {\n    return this.store;\n  }\n}\n\nconst configuredStore = new Store(zipParse(storeCache.store), { useRedis: false });\n\nexport { configuredStore, Store };\n"]},"metadata":{},"sourceType":"module"}