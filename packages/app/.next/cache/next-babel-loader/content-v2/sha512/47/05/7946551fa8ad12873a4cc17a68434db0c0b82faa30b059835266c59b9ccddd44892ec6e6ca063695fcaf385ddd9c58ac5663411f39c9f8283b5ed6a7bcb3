{"ast":null,"code":"import { traverseProductsBySection, traverseProductsByCategory, traverseAllProducts, eachCategoryCb, simpleSearchMatcher } from '../helper';\nimport { urlCaseMatches } from '@helpers/common';\n\nfunction productsByBrandAndSection(affiliateData, brand, section) {\n  const products = [];\n  traverseProductsBySection(affiliateData, section, {\n    level: 'product',\n    cb: product => {\n      var _product$metaData;\n\n      if (urlCaseMatches(product === null || product === void 0 ? void 0 : (_product$metaData = product.metaData) === null || _product$metaData === void 0 ? void 0 : _product$metaData.brand, brand, false)) {\n        products.push(product);\n      }\n    }\n  });\n  return products;\n}\n\nfunction productsByTermAndSec(affiliateData, section, keyTerm) {\n  const products = [];\n  traverseProductsBySection(affiliateData, section, {\n    level: 'product',\n    cb: product => {\n      const {\n        topLevelData\n      } = product;\n\n      if (simpleSearchMatcher(topLevelData === null || topLevelData === void 0 ? void 0 : topLevelData.tags, keyTerm)) {\n        products.push(product);\n      }\n    }\n  });\n  return products;\n}\n\nfunction productsByBrandAndCat(affiliateData, brand, section, category) {\n  const products = [];\n  traverseProductsByCategory(affiliateData, section, category, product => {\n    var _product$metaData2;\n\n    if (urlCaseMatches(product === null || product === void 0 ? void 0 : (_product$metaData2 = product.metaData) === null || _product$metaData2 === void 0 ? void 0 : _product$metaData2.brand, brand, false)) {\n      products.push(product);\n    }\n  });\n  return products;\n}\n\nfunction productsByColorAndCat(affiliateData, section, category, productColor) {\n  const products = [];\n  traverseProductsByCategory(affiliateData, section, category, product => {\n    var _product$topLevelData;\n\n    if ((_product$topLevelData = product.topLevelData.tags) !== null && _product$topLevelData !== void 0 && _product$topLevelData.includes(productColor)) products.push(product);\n  });\n  return products;\n}\n\nfunction productsByColorAndCatAndTerm(affiliateData, section, category, keyTerm, productColor) {\n  const products = [];\n  traverseProductsByCategory(affiliateData, section, category, product => {\n    var _topLevelData$tags;\n\n    const {\n      topLevelData\n    } = product;\n\n    if ((_topLevelData$tags = topLevelData.tags) !== null && _topLevelData$tags !== void 0 && _topLevelData$tags.includes(productColor) && simpleSearchMatcher(topLevelData === null || topLevelData === void 0 ? void 0 : topLevelData.tags, keyTerm)) {\n      products.push(product);\n    }\n  });\n  return products;\n}\n\nfunction productsByTermAndCat(affiliateData, section, category, keyTerm) {\n  const products = [];\n  traverseProductsByCategory(affiliateData, section, category, product => {\n    const {\n      topLevelData\n    } = product;\n\n    if (simpleSearchMatcher(topLevelData === null || topLevelData === void 0 ? void 0 : topLevelData.tags, keyTerm)) {\n      products.push(product);\n    }\n  });\n  return products;\n}\n\nfunction productsByCat(affiliateData, section, category) {\n  const products = [];\n  eachCategoryCb(affiliateData, section, cat => {\n    if (Array.isArray(category)) {\n      if (category.some(catItem => urlCaseMatches(catItem, cat.category))) {\n        products.push.apply(products, cat.data);\n      }\n    } else {\n      if (urlCaseMatches(category, cat.category)) {\n        products.push.apply(products, cat.data);\n      }\n    }\n  });\n  return products;\n}\n\nfunction productsBySection(affiliateData, section) {\n  const products = [];\n  eachCategoryCb(affiliateData, section, cat => {\n    products.push.apply(products, cat.data);\n  });\n  return products;\n}\n\nfunction getAllproducts(affiliateData) {\n  let products = [];\n  traverseAllProducts(affiliateData, {\n    level: 'category',\n    cb: cat => {\n      products.push.apply(products, cat.data);\n    }\n  });\n  return products;\n}\n\nfunction productsByTermOnly(affiliateData, keyTerm) {\n  const priorityProducts = [];\n  const secondaryProducts = [];\n  const tertiaryProducts = [];\n  traverseAllProducts(affiliateData, {\n    level: 'product',\n    cb: product => {\n      const {\n        tags\n      } = product.topLevelData;\n      if (!tags) return; // This is sensitive code in that we are looping through all products, so we should avoid\n      // extra logic and expensive operations! This is why we are using a standard for loop below.\n      // Note the tertiary condition will be activated only if we fail to match a primary condition\n      // and serves as a last attempt to match a search term. Will match if the key term itself\n      // includes a given tag. For example if a tag is \"sock\" and the term is \"socks123\"\n      // a match will be presented. However, if there is too much difference in the terms (by length)\n      // then the match will be disgarded for the tertiary condition\n\n      for (let i = 0; i < tags.length; i++) {\n        if (tags[i] === keyTerm) {\n          priorityProducts.push(product);\n          return;\n        } else if (tags[i].includes(keyTerm)) {\n          secondaryProducts.push(product);\n          return;\n        } else if (keyTerm.includes(tags[i])) {\n          if (keyTerm.length - tags[i].length < 3) {\n            tertiaryProducts.push(product);\n          }\n\n          break;\n        }\n      }\n\n      if (simpleSearchMatcher(tags, keyTerm)) {\n        secondaryProducts.push(product);\n      }\n    }\n  });\n  return [...priorityProducts, ...secondaryProducts, ...tertiaryProducts];\n}\n\nexport function searchPipe(affiliateData, {\n  category,\n  keyTerm,\n  productColor,\n  section,\n  brand\n}) {\n  if (brand && section && category) {\n    return productsByBrandAndCat(affiliateData, brand, section, category);\n  } else if (brand && section) {\n    return productsByBrandAndSection(affiliateData, brand, section);\n  } else if (productColor && section && category && keyTerm) {\n    return productsByColorAndCatAndTerm(affiliateData, section, category, keyTerm, productColor);\n  } else if (productColor && section && category) {\n    return productsByColorAndCat(affiliateData, section, category, productColor);\n  } else if (keyTerm && section && category) {\n    return productsByTermAndCat(affiliateData, section, category, keyTerm);\n  } else if (keyTerm && section) {\n    return productsByTermAndSec(affiliateData, section, keyTerm);\n  } else if (section && category) {\n    return productsByCat(affiliateData, section, category);\n  } else if (brand) {\n    return productsByBrandAndSection(affiliateData, brand, 'womens');\n  } else if (section) {\n    return productsBySection(affiliateData, section);\n  } else if (keyTerm) {\n    return productsByTermOnly(affiliateData, keyTerm);\n  } else {\n    return getAllproducts(affiliateData);\n  }\n}\nexport function searchResultShapePipe(products, categoryLastUpdated) {\n  return [{\n    category: 'Search Results',\n    label: 'clothing',\n    data: products,\n    categoryLastUpdated\n  }];\n}","map":{"version":3,"sources":["/Users/justincoulston/Desktop/affilaite-core-mono/packages/affiliate-app/graphQL/resolvers/resolverPipes/searchPipe.js"],"names":["traverseProductsBySection","traverseProductsByCategory","traverseAllProducts","eachCategoryCb","simpleSearchMatcher","urlCaseMatches","productsByBrandAndSection","affiliateData","brand","section","products","level","cb","product","metaData","push","productsByTermAndSec","keyTerm","topLevelData","tags","productsByBrandAndCat","category","productsByColorAndCat","productColor","includes","productsByColorAndCatAndTerm","productsByTermAndCat","productsByCat","cat","Array","isArray","some","catItem","apply","data","productsBySection","getAllproducts","productsByTermOnly","priorityProducts","secondaryProducts","tertiaryProducts","i","length","searchPipe","searchResultShapePipe","categoryLastUpdated","label"],"mappings":"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","sourcesContent":["//@flow\nimport {\n  traverseProductsBySection,\n  traverseProductsByCategory,\n  traverseAllProducts,\n  eachCategoryCb,\n  simpleSearchMatcher,\n} from '../helper';\nimport { type ProductsData, type ProductData, type ProductCategory } from '@types/product';\nimport { type PredictiveSearch } from '@types/search';\nimport { urlCaseMatches } from '@helpers/common';\n\nfunction productsByBrandAndSection(\n  affiliateData: ProductsData,\n  brand: string,\n  section: string\n): Array<ProductData> {\n  const products = [];\n  traverseProductsBySection(affiliateData, section, {\n    level: 'product',\n    cb: (product) => {\n      if (urlCaseMatches(product?.metaData?.brand, brand, false)) {\n        products.push(product);\n      }\n    },\n  });\n\n  return products;\n}\n\nfunction productsByTermAndSec(\n  affiliateData: ProductsData,\n  section: string,\n  keyTerm: string\n): Array<ProductData> {\n  const products = [];\n  traverseProductsBySection(affiliateData, section, {\n    level: 'product',\n    cb: (product) => {\n      const { topLevelData } = product;\n      if (simpleSearchMatcher(topLevelData?.tags, keyTerm)) {\n        products.push(product);\n      }\n    },\n  });\n\n  return products;\n}\n\nfunction productsByBrandAndCat(\n  affiliateData: ProductsData,\n  brand: string,\n  section: string,\n  category: string\n): Array<ProductData> {\n  const products = [];\n  traverseProductsByCategory(affiliateData, section, category, (product) => {\n    if (urlCaseMatches(product?.metaData?.brand, brand, false)) {\n      products.push(product);\n    }\n  });\n  return products;\n}\n\nfunction productsByColorAndCat(\n  affiliateData: ProductsData,\n  section: string,\n  category: string,\n  productColor: string\n): Array<ProductData> {\n  const products = [];\n  traverseProductsByCategory(affiliateData, section, category, (product) => {\n    if (product.topLevelData.tags?.includes(productColor)) products.push(product);\n  });\n  return products;\n}\n\nfunction productsByColorAndCatAndTerm(\n  affiliateData: ProductsData,\n  section: string,\n  category: string,\n  keyTerm: string,\n  productColor: string\n): Array<ProductData> {\n  const products = [];\n  traverseProductsByCategory(affiliateData, section, category, (product) => {\n    const { topLevelData } = product;\n    if (\n      topLevelData.tags?.includes(productColor) &&\n      simpleSearchMatcher(topLevelData?.tags, keyTerm)\n    ) {\n      products.push(product);\n    }\n  });\n  return products;\n}\n\nfunction productsByTermAndCat(\n  affiliateData: ProductsData,\n  section: string,\n  category: string,\n  keyTerm: string\n): Array<ProductData> {\n  const products = [];\n  traverseProductsByCategory(affiliateData, section, category, (product) => {\n    const { topLevelData } = product;\n    if (simpleSearchMatcher(topLevelData?.tags, keyTerm)) {\n      products.push(product);\n    }\n  });\n  return products;\n}\n\nfunction productsByCat(\n  affiliateData: ProductsData,\n  section: string,\n  category: string\n): Array<ProductData> {\n  const products = [];\n\n  eachCategoryCb(affiliateData, section, (cat) => {\n    if (Array.isArray(category)) {\n      if (category.some((catItem) => urlCaseMatches(catItem, cat.category))) {\n        products.push.apply(products, cat.data);\n      }\n    } else {\n      if (urlCaseMatches(category, cat.category)) {\n        products.push.apply(products, cat.data);\n      }\n    }\n  });\n  return products;\n}\n\nfunction productsBySection(affiliateData: ProductsData, section: string): Array<ProductData> {\n  const products = [];\n\n  eachCategoryCb(affiliateData, section, (cat) => {\n    products.push.apply(products, cat.data);\n  });\n  return products;\n}\n\nfunction getAllproducts(affiliateData: ProductsData): Array<ProductData> {\n  let products = [];\n  traverseAllProducts(affiliateData, {\n    level: 'category',\n    cb: (cat) => {\n      products.push.apply(products, cat.data);\n    },\n  });\n\n  return products;\n}\n\nfunction productsByTermOnly(affiliateData: ProductsData, keyTerm: string): Array<ProductData> {\n  const priorityProducts = [];\n  const secondaryProducts = [];\n  const tertiaryProducts = [];\n\n  traverseAllProducts(affiliateData, {\n    level: 'product',\n    cb: (product) => {\n      const { tags } = product.topLevelData;\n      if (!tags) return;\n      // This is sensitive code in that we are looping through all products, so we should avoid\n      // extra logic and expensive operations! This is why we are using a standard for loop below.\n      // Note the tertiary condition will be activated only if we fail to match a primary condition\n      // and serves as a last attempt to match a search term. Will match if the key term itself\n      // includes a given tag. For example if a tag is \"sock\" and the term is \"socks123\"\n      // a match will be presented. However, if there is too much difference in the terms (by length)\n      // then the match will be disgarded for the tertiary condition\n      for (let i = 0; i < tags.length; i++) {\n        if (tags[i] === keyTerm) {\n          priorityProducts.push(product);\n          return;\n        } else if (tags[i].includes(keyTerm)) {\n          secondaryProducts.push(product);\n          return;\n        } else if (keyTerm.includes(tags[i])) {\n          if (keyTerm.length - tags[i].length < 3) {\n            tertiaryProducts.push(product);\n          }\n          break;\n        }\n      }\n\n      if (simpleSearchMatcher(tags, keyTerm)) {\n        secondaryProducts.push(product);\n      }\n    },\n  });\n\n  return [...priorityProducts, ...secondaryProducts, ...tertiaryProducts];\n}\n\nexport function searchPipe(\n  affiliateData: ProductsData,\n  { category, keyTerm, productColor, section, brand }: PredictiveSearch\n): Array<ProductData> {\n  if (brand && section && category) {\n    return productsByBrandAndCat(affiliateData, brand, section, category);\n  } else if (brand && section) {\n    return productsByBrandAndSection(affiliateData, brand, section);\n  } else if (productColor && section && category && keyTerm) {\n    return productsByColorAndCatAndTerm(affiliateData, section, category, keyTerm, productColor);\n  } else if (productColor && section && category) {\n    return productsByColorAndCat(affiliateData, section, category, productColor);\n  } else if (keyTerm && section && category) {\n    return productsByTermAndCat(affiliateData, section, category, keyTerm);\n  } else if (keyTerm && section) {\n    return productsByTermAndSec(affiliateData, section, keyTerm);\n  } else if (section && category) {\n    return productsByCat(affiliateData, section, category);\n  } else if (brand) {\n    return productsByBrandAndSection(affiliateData, brand, 'womens');\n  } else if (section) {\n    return productsBySection(affiliateData, section);\n  } else if (keyTerm) {\n    return productsByTermOnly(affiliateData, keyTerm);\n  } else {\n    return getAllproducts(affiliateData);\n  }\n}\n\nexport function searchResultShapePipe(\n  products: Array<ProductData>,\n  categoryLastUpdated: string\n): Array<ProductCategory> {\n  return [\n    {\n      category: 'Search Results',\n      label: 'clothing',\n      data: products,\n      categoryLastUpdated,\n    },\n  ];\n}\n"]},"metadata":{},"sourceType":"module"}