{"ast":null,"code":"import { crossIncludes } from '@helpers/common';\nexport function getTermString(predictiveTerms, useSplitter) {\n  if (typeof predictiveTerms === 'string') {\n    return predictiveTerms;\n  } else {\n    const values = Object.values(predictiveTerms).filter(notNull => !!notNull);\n    return values.join(useSplitter ? ' | ' : ' ');\n  }\n}\nexport function getPredictiveTermsList(predictiveTermsResponse, value) {\n  const suggestions = [];\n  const pushedTerms = [];\n\n  const valueMatch = (p1, p2) => p1 && p2 ? (p1 === null || p1 === void 0 ? void 0 : p1.includes(p2)) || (p2 === null || p2 === void 0 ? void 0 : p2.includes(p1)) : false;\n\n  const pushSuggestion = term => {\n    const termStr = JSON.stringify(term);\n\n    if (!pushedTerms.includes(termStr)) {\n      pushedTerms.push(termStr);\n      suggestions.push(term);\n    }\n  };\n\n  for (const term of predictiveTermsResponse) {\n    const {\n      brand,\n      section,\n      productColor,\n      keyTerm,\n      category\n    } = term;\n\n    if (valueMatch(section, value) && category) {\n      pushSuggestion({\n        section\n      });\n      pushSuggestion({\n        section,\n        category\n      });\n    }\n\n    if (valueMatch(brand, value)) {\n      pushSuggestion({\n        brand\n      });\n      if (section) pushSuggestion({\n        section,\n        brand\n      });\n      if (category) pushSuggestion({\n        section,\n        brand,\n        category\n      });\n    }\n\n    if (valueMatch(productColor, value)) {\n      if (category) pushSuggestion({\n        section,\n        productColor,\n        category\n      });\n\n      if (category && keyTerm && !crossIncludes(category, keyTerm)) {\n        pushSuggestion({\n          section,\n          productColor,\n          keyTerm,\n          category\n        });\n      }\n    }\n\n    if (valueMatch(keyTerm, value) && category && !crossIncludes(category, keyTerm)) {\n      pushSuggestion({\n        section,\n        keyTerm,\n        category\n      });\n    }\n\n    if (valueMatch(category, value)) {\n      if (section) pushSuggestion({\n        section,\n        category\n      });\n    }\n  }\n\n  return suggestions;\n}","map":{"version":3,"sources":["/Users/justincoulston/Desktop/affilaite-core-mono/packages/app/components/modules/Search/helper.js"],"names":["crossIncludes","getTermString","predictiveTerms","useSplitter","values","Object","filter","notNull","join","getPredictiveTermsList","predictiveTermsResponse","value","suggestions","pushedTerms","valueMatch","p1","p2","includes","pushSuggestion","term","termStr","JSON","stringify","push","brand","section","productColor","keyTerm","category"],"mappings":"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","sourcesContent":["//@flow\nimport { type PredictiveSearch } from '@types/search';\nimport { crossIncludes } from '@helpers/common';\n\nexport function getTermString(predictiveTerms: PredictiveSearch, useSplitter?: boolean): string {\n  if (typeof predictiveTerms === 'string') {\n    return predictiveTerms;\n  } else {\n    const values = Object.values(predictiveTerms).filter((notNull) => !!notNull);\n    return values.join(useSplitter ? ' | ' : ' ');\n  }\n}\n\nexport function getPredictiveTermsList(\n  predictiveTermsResponse: Array<PredictiveSearch>,\n  value: string\n): Array<PredictiveSearch> {\n  const suggestions = [];\n  const pushedTerms = [];\n\n  const valueMatch = (p1, p2): boolean => (p1 && p2 ? p1?.includes(p2) || p2?.includes(p1) : false);\n  const pushSuggestion = (term) => {\n    const termStr = JSON.stringify(term);\n    if (!pushedTerms.includes(termStr)) {\n      pushedTerms.push(termStr);\n      suggestions.push(term);\n    }\n  };\n\n  for (const term of predictiveTermsResponse) {\n    const { brand, section, productColor, keyTerm, category } = term;\n\n    if (valueMatch(section, value) && category) {\n      pushSuggestion({ section });\n      pushSuggestion({ section, category });\n    }\n\n    if (valueMatch(brand, value)) {\n      pushSuggestion({ brand });\n      if (section) pushSuggestion({ section, brand });\n      if (category) pushSuggestion({ section, brand, category });\n    }\n\n    if (valueMatch(productColor, value)) {\n      if (category) pushSuggestion({ section, productColor, category });\n      if (category && keyTerm && !crossIncludes(category, keyTerm)) {\n        pushSuggestion({ section, productColor, keyTerm, category });\n      }\n    }\n\n    if (valueMatch(keyTerm, value) && category && !crossIncludes(category, keyTerm)) {\n      pushSuggestion({ section, keyTerm, category });\n    }\n\n    if (valueMatch(category, value)) {\n      if (section) pushSuggestion({ section, category });\n    }\n  }\n\n  return suggestions;\n}\n"]},"metadata":{},"sourceType":"module"}