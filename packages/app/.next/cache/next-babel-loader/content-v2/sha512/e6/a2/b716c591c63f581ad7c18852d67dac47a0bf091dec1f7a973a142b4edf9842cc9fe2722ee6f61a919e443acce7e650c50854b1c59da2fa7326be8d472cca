{"ast":null,"code":"import _extends from \"/Users/justincoulston/Desktop/affilaite-core-mono/node_modules/next/node_modules/@babel/runtime/helpers/esm/extends\";\nimport _defineProperty from \"/Users/justincoulston/Desktop/affilaite-core-mono/node_modules/next/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _toConsumableArray from \"/Users/justincoulston/Desktop/affilaite-core-mono/node_modules/next/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _asyncToGenerator from \"/Users/justincoulston/Desktop/affilaite-core-mono/node_modules/next/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nvar __jsx = React.createElement;\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\n\n/* eslint-disable no-use-before-define */\nimport React, { useState, useRef } from 'react';\nimport TextField from '@material-ui/core/TextField';\nimport SearchIcon from '@material-ui/icons/Search';\nimport Grid from '@material-ui/core/Grid';\nimport { Flex, Actionable } from '@styles/CommonStyledComponents';\nimport ClearIcon from '@material-ui/icons/Clear';\nimport clientRequests from '../../../apiUtil/requests/clientRequests';\nimport { getPredictiveTermsList, getTermString } from './helper';\nimport { SEARCH_PATH } from '@constants';\nimport kebabCase from 'lodash/kebabCase';\nimport debounce from 'lodash/debounce';\nimport Drawer from '@units/Drawer';\nimport { useRouter } from 'next/router';\nimport { urlCase, delayedCallback, betterThrottle, createEvent } from '@helpers/common';\nimport { useTheme, useCms } from '@hooks';\nimport Loader from '@units/Loader';\nimport SearchInputWrapper from './SearchInputWrapper';\nimport { ClearIconContainer, ToogledSearchContainer, SearchContainer, SearchInput, SearchAutoCompleteBoxStyle, SuggestedText, DekstopSearchAction, LoaderContainer } from './style';\nexport default function Search(_ref) {\n  var isToggleSearch = _ref.isToggleSearch,\n      onSubmitCallback = _ref.onSubmitCallback;\n\n  var _useTheme = useTheme(),\n      textTheme = _useTheme.textTheme;\n\n  var _useState = useState(false),\n      searchToggled = _useState[0],\n      setSearchToggled = _useState[1];\n\n  var _useState2 = useState([]),\n      options = _useState2[0],\n      setOptions = _useState2[1];\n\n  var _useState3 = useState([]),\n      inputValue = _useState3[0],\n      setInputValue = _useState3[1];\n\n  var _useState4 = useState(false),\n      predictiveLoading = _useState4[0],\n      setPredictiveLoading = _useState4[1];\n\n  var inputRef = React.useRef();\n  var router = useRouter();\n\n  var _useCms = useCms('header'),\n      searchCms = _useCms.search;\n\n  var searchIconColor = searchCms.searchIconColor,\n      searchBarColor = searchCms.searchBarColor;\n  var apiThrottleTimeout;\n  var smoothLoaderControler;\n\n  var handleSetToggled = function handleSetToggled() {\n    return setSearchToggled(!searchToggled);\n  };\n\n  var setPredictiveSearch = /*#__PURE__*/function () {\n    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(value) {\n      var result, predivtiveTerms;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return clientRequests.getPredictiveSearch(value);\n\n            case 2:\n              result = _context.sent;\n              setPredictiveLoading(false);\n              predivtiveTerms = getPredictiveTermsList(result, value);\n              setOptions([{\n                keyTerm: \"\\\"\".concat(value, \"\\\"\")\n              }].concat(_toConsumableArray(predivtiveTerms)));\n\n            case 6:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    return function setPredictiveSearch(_x) {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n\n  var handlePredictiveSearch = /*#__PURE__*/function () {\n    var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(_ref3) {\n      var value, valueCase;\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              value = _ref3.target.value;\n              valueCase = value.toLowerCase();\n              setInputValue(valueCase);\n              if (apiThrottleTimeout) clearTimeout(apiThrottleTimeout);\n              apiThrottleTimeout = setTimeout(function () {\n                // throttle reduces 'glitchy' loader animations caused by quick typing\n                betterThrottle(function () {\n                  return setPredictiveLoading(!!value);\n                });\n\n                if (value.length > 2) {\n                  setPredictiveSearch(valueCase);\n                }\n              }, 500);\n\n            case 5:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }));\n\n    return function handlePredictiveSearch(_x2) {\n      return _ref4.apply(this, arguments);\n    };\n  }();\n\n  var goToSearch = function goToSearch(page) {\n    if (onSubmitCallback) onSubmitCallback();\n    setSearchToggled(false);\n    router.push(page);\n  };\n\n  var handleAutoCompleteClick = function handleAutoCompleteClick(option) {\n    var searchParams = Object.keys(option).reduce(function (acc, cur) {\n      var _option$cur;\n\n      return \"\".concat(acc).concat(kebabCase(cur), \"=\").concat(urlCase((_option$cur = option[cur]) === null || _option$cur === void 0 ? void 0 : _option$cur.replace(/\\\"/g, '')), \"&\");\n    }, \"/\".concat(SEARCH_PATH, \"?\")).slice(0, -1);\n    handleSetToggled();\n    goToSearch(searchParams);\n  };\n\n  var initLooseSearch = function initLooseSearch() {\n    if (inputValue && inputValue.length > 2) {\n      goToSearch(\"/\".concat(SEARCH_PATH, \"?key-term=\").concat(urlCase(inputValue)));\n      handleSetToggled();\n    }\n  };\n\n  var handleKeyDownSearch = function handleKeyDownSearch() {\n    return function (_ref5) {\n      var keyCode = _ref5.keyCode;\n      if (keyCode === 13) initLooseSearch();\n    };\n  };\n\n  var renderNoToggleSearch = __jsx(SearchInputWrapper, {\n    searchToggled: searchToggled,\n    initLooseSearch: initLooseSearch,\n    searchIconColor: searchIconColor,\n    searchBarColor: searchBarColor\n  }, __jsx(SearchInput, {\n    freeSolo: true,\n    ignoreCase: true,\n    disableClearable: true,\n    getOptionLabel: function getOptionLabel(option) {\n      return getTermString(option);\n    },\n    renderOption: function renderOption(option) {\n      return __jsx(SuggestedText, {\n        onClick: function onClick() {\n          return handleAutoCompleteClick(option);\n        }\n      }, getTermString(option));\n    },\n    options: options,\n    renderInput: function renderInput(params) {\n      return __jsx(TextField, _extends({}, params, {\n        onChange: handlePredictiveSearch,\n        label: \"\",\n        autoFocus: searchToggled,\n        variant: \"outlined\",\n        margin: \"normal\",\n        inputRef: inputRef,\n        InputProps: _objectSpread(_objectSpread({}, params.InputProps), {}, {\n          type: 'search'\n        }),\n        onBlur: function onBlur() {\n          return createEvent(inputRef.current, 'mousedown', 50);\n        },\n        onKeyDown: handleKeyDownSearch()\n      }));\n    }\n  }));\n\n  return __jsx(React.Fragment, null, __jsx(Drawer, {\n    open: searchToggled,\n    anchor: \"left\",\n    width: 70,\n    onClose: function onClose() {\n      return setPredictiveLoading(false);\n    }\n  }, __jsx(\"div\", null, __jsx(SearchAutoCompleteBoxStyle, {\n    theme: textTheme\n  }), __jsx(ToogledSearchContainer, null, __jsx(ClearIconContainer, null, __jsx(Actionable, {\n    \"aria-label\": \"search\"\n  }, __jsx(ClearIcon, {\n    fontSize: \"large\",\n    onClick: handleSetToggled\n  }))), renderNoToggleSearch, __jsx(LoaderContainer, null, __jsx(Loader, {\n    active: predictiveLoading\n  }))))), isToggleSearch ? __jsx(SearchIcon, {\n    color: searchIconColor,\n    fontSize: \"large\",\n    onClick: handleSetToggled\n  }) : __jsx(SearchInputWrapper, {\n    searchToggled: searchToggled,\n    handleSetToggled: handleSetToggled,\n    initLooseSearch: initLooseSearch,\n    searchIconColor: searchIconColor,\n    searchBarColor: searchBarColor\n  }, __jsx(DekstopSearchAction, {\n    fullWidth: true,\n    variant: \"outlined\"\n  })));\n}","map":null,"metadata":{},"sourceType":"module"}