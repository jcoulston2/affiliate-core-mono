{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport { srcToHttp, getSingle, toArray } from '@helpers/common';\nimport { formatDistance } from 'date-fns';\nexport function hasValidTabbedData(data, isDefault) {\n  return !!isDefault || data.filter(isNull => !isNull).length !== data.length;\n}\nexport function mapCustomDataToTabs(customDescriptiveData) {\n  return customDescriptiveData.map(item => ({\n    title: item.customText,\n    data: item.data.map(notNull => notNull)\n  }));\n}\nexport function normalizeSingleImage(src, domain) {\n  const toHttp = srcToHttp(src);\n  return toHttp.startsWith('/') ? domain + src : toHttp;\n}\nexport function reduceDuplicateUrls(urls) {\n  return urls.reduce((acc, cur) => {\n    const includesBaseUrl = acc.some(checkedUrl => {\n      const params = new URL(cur);\n      const query = params.search;\n      const base = cur.replace(query, '');\n      return checkedUrl.includes(base);\n    });\n    return includesBaseUrl ? acc : [...acc, cur];\n  }, []);\n}\nexport function hasRequiredProductInformation({\n  detailedData,\n  topLevelData,\n  metaData\n}) {\n  return !!(detailedData && topLevelData && metaData);\n}\nexport function normalizeTopLevelProductData(data) {\n  const normalized = Object.keys(data).reduce((accum, cur) => {\n    return _objectSpread(_objectSpread({}, accum), {}, {\n      [cur]: Array.isArray(data[cur]) ? data[cur][0] : data[cur]\n    });\n  }, {});\n  return normalized;\n} // Although rare, there may be some cases where we always want to return a single value\n// instead of an array of values. This helper function just provides an extra security layer\n// incase we have accidentally defined a selector which picks up multiple values\n\nexport function normalizeDetailProductData(data) {\n  let normalized = {};\n  Object.keys(data).forEach(detailDataKey => {\n    const detailDataValue = data[detailDataKey];\n\n    switch (detailDataKey) {\n      case 'selectedColor':\n        normalized[detailDataKey] = getSingle(detailDataValue);\n        break;\n      // we can skip custom and variants as they are special cases\n\n      case 'variants':\n      case 'custom':\n        normalized[detailDataKey] = detailDataValue;\n        break;\n\n      default:\n        normalized[detailDataKey] = toArray(detailDataValue);\n        break;\n    }\n  });\n  return normalized;\n}\nexport function getCustomDescriptiveData(customData) {\n  return (customData === null || customData === void 0 ? void 0 : customData.filter(customDataItem => customDataItem.data.some(dataItem => dataItem.isDescriptive))) || [];\n}\nexport function getCustomPrimaryData(customData) {\n  return (customData === null || customData === void 0 ? void 0 : customData.filter(customDataItem => customDataItem.data.some(dataItem => dataItem.isPrimary)).map(item => _objectSpread(_objectSpread({}, item), {}, {\n    variantText: item.customText\n  }))) || [];\n}\nexport function getPriceLastUpdated(categoryLastUpdated) {\n  const lastUpdated = categoryLastUpdated ? formatDistance(new Date(categoryLastUpdated), new Date(), {\n    addSuffix: true\n  }) : null;\n  const tooLongThreshold = lastUpdated && /year|month/.test(lastUpdated);\n  return tooLongThreshold ? null : lastUpdated;\n} // TODO: the below logic should really be removed from core, since the logic exists in the extractor service,\n// we just need to remember to add the \"omitDuplicateImgByBase\" when defening schemas for brands that pick up\n// multiple differing quality params! Or we should set omitDuplicateImgByBase to true by default. See the\n// extractor service for more details\n\nlet validatedImages = [];\nexport function isDuplicateImg(src, omitDuplicateImgByBase) {\n  let isDuplicate;\n  if (!src) return false;\n\n  if (omitDuplicateImgByBase) {\n    const params = new URL(src);\n    const query = params.search;\n    const base = src.replace(query, '');\n    isDuplicate = validatedImages.includes(base);\n    if (!isDuplicate) validatedImages.push(base);\n  } else {\n    isDuplicate = validatedImages.includes(src);\n    if (!isDuplicate) validatedImages.push(src);\n  }\n\n  return isDuplicate;\n} // TODO: see above comment\n\nexport function getValidImages(images) {\n  validatedImages = [];\n  return images.filter(img => !isDuplicateImg(img, true));\n}","map":{"version":3,"sources":["/Users/justincoulston/Desktop/affilaite-core-mono/packages/affiliate-app/components/modules/ProductDetailView/helper.js"],"names":["srcToHttp","getSingle","toArray","formatDistance","hasValidTabbedData","data","isDefault","filter","isNull","length","mapCustomDataToTabs","customDescriptiveData","map","item","title","customText","notNull","normalizeSingleImage","src","domain","toHttp","startsWith","reduceDuplicateUrls","urls","reduce","acc","cur","includesBaseUrl","some","checkedUrl","params","URL","query","search","base","replace","includes","hasRequiredProductInformation","detailedData","topLevelData","metaData","normalizeTopLevelProductData","normalized","Object","keys","accum","Array","isArray","normalizeDetailProductData","forEach","detailDataKey","detailDataValue","getCustomDescriptiveData","customData","customDataItem","dataItem","isDescriptive","getCustomPrimaryData","isPrimary","variantText","getPriceLastUpdated","categoryLastUpdated","lastUpdated","Date","addSuffix","tooLongThreshold","test","validatedImages","isDuplicateImg","omitDuplicateImgByBase","isDuplicate","push","getValidImages","images","img"],"mappings":"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","sourcesContent":["//@flow\nimport {\n  type ProductDetailedData,\n  type ProductTopLevelData,\n  type ProductCustomVariant,\n  type ProductData,\n} from '@types/product';\nimport { srcToHttp, getSingle, toArray } from '@helpers/common';\nimport { formatDistance } from 'date-fns';\n\nexport function hasValidTabbedData(data: Array<string>, isDefault: ?boolean): boolean {\n  return !!isDefault || data.filter((isNull) => !isNull).length !== data.length;\n}\n\nexport function mapCustomDataToTabs(\n  customDescriptiveData: Array<ProductCustomVariant>\n): Array<{ title: string, data: any }> {\n  return customDescriptiveData.map((item) => ({\n    title: item.customText,\n    data: item.data.map((notNull) => notNull),\n  }));\n}\n\nexport function normalizeSingleImage(src: string, domain: string): string {\n  const toHttp = srcToHttp(src);\n  return toHttp.startsWith('/') ? domain + src : toHttp;\n}\n\nexport function reduceDuplicateUrls(urls: Array<string>): Array<string> {\n  return urls.reduce((acc, cur) => {\n    const includesBaseUrl = acc.some((checkedUrl) => {\n      const params = new URL(cur);\n      const query = params.search;\n      const base = cur.replace(query, '');\n      return checkedUrl.includes(base);\n    });\n    return includesBaseUrl ? acc : [...acc, cur];\n  }, []);\n}\n\nexport function hasRequiredProductInformation({\n  detailedData,\n  topLevelData,\n  metaData,\n}: ProductData): boolean {\n  return !!(detailedData && topLevelData && metaData);\n}\n\nexport function normalizeTopLevelProductData(data: ProductTopLevelData): ProductTopLevelData {\n  const normalized = Object.keys(data).reduce((accum: Object, cur: Object) => {\n    return {\n      ...accum,\n      [cur]: Array.isArray(data[cur]) ? data[cur][0] : data[cur],\n    };\n  }, {});\n\n  return normalized;\n}\n\n// Although rare, there may be some cases where we always want to return a single value\n// instead of an array of values. This helper function just provides an extra security layer\n// incase we have accidentally defined a selector which picks up multiple values\nexport function normalizeDetailProductData(\n  data: ProductDetailedData\n): {\n  ...ProductDetailedData,\n  selectedColor: string,\n} {\n  let normalized = {};\n  Object.keys(data).forEach((detailDataKey) => {\n    const detailDataValue: any = data[detailDataKey];\n    switch (detailDataKey) {\n      case 'selectedColor':\n        normalized[detailDataKey] = getSingle(detailDataValue);\n        break;\n\n      // we can skip custom and variants as they are special cases\n      case 'variants':\n      case 'custom':\n        normalized[detailDataKey] = detailDataValue;\n        break;\n\n      default:\n        normalized[detailDataKey] = toArray(detailDataValue);\n        break;\n    }\n  });\n\n  return normalized;\n}\n\nexport function getCustomDescriptiveData(\n  customData: ?Array<ProductCustomVariant>\n): Array<ProductCustomVariant> {\n  return (\n    customData?.filter((customDataItem) =>\n      customDataItem.data.some((dataItem) => dataItem.isDescriptive)\n    ) || []\n  );\n}\n\nexport function getCustomPrimaryData(\n  customData: ?Array<ProductCustomVariant>\n): Array<{ variantText: string, data: Array<Object> }> {\n  return (\n    customData\n      ?.filter((customDataItem) => customDataItem.data.some((dataItem) => dataItem.isPrimary))\n      .map((item) => ({\n        ...item,\n        variantText: item.customText,\n      })) || []\n  );\n}\n\nexport function getPriceLastUpdated(categoryLastUpdated?: string): ?string {\n  const lastUpdated = categoryLastUpdated\n    ? formatDistance(new Date(categoryLastUpdated), new Date(), {\n        addSuffix: true,\n      })\n    : null;\n  const tooLongThreshold = lastUpdated && /year|month/.test(lastUpdated);\n  return tooLongThreshold ? null : lastUpdated;\n}\n\n// TODO: the below logic should really be removed from core, since the logic exists in the extractor service,\n// we just need to remember to add the \"omitDuplicateImgByBase\" when defening schemas for brands that pick up\n// multiple differing quality params! Or we should set omitDuplicateImgByBase to true by default. See the\n// extractor service for more details\nlet validatedImages = [];\nexport function isDuplicateImg(src: string, omitDuplicateImgByBase: boolean): boolean {\n  let isDuplicate;\n  if (!src) return false;\n  if (omitDuplicateImgByBase) {\n    const params = new URL(src);\n    const query = params.search;\n    const base = src.replace(query, '');\n    isDuplicate = validatedImages.includes(base);\n    if (!isDuplicate) validatedImages.push(base);\n  } else {\n    isDuplicate = validatedImages.includes(src);\n    if (!isDuplicate) validatedImages.push(src);\n  }\n\n  return isDuplicate;\n}\n\n// TODO: see above comment\nexport function getValidImages(images: Array<string>): Array<string> {\n  validatedImages = [];\n  return images.filter((img) => !isDuplicateImg(img, true));\n}\n"]},"metadata":{},"sourceType":"module"}