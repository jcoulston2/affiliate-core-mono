{"ast":null,"code":"import _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport { MultiString } from '../customScalars';\nimport GraphQLJSON, { GraphQLJSONObject } from 'graphql-type-json';\nimport { getCategoryLastUpdated, traverseAllProducts } from './helper';\nimport { searchPipe, productCountPipe, searchResultShapePipe, categoryPipe, filterPipe } from './resolverPipes';\nexport default function productResolver(affiliateData) {\n  const scalars = {\n    MultiString,\n    JSON: GraphQLJSON,\n    JSONObject: GraphQLJSONObject\n  };\n  return _objectSpread(_objectSpread({}, scalars), {}, {\n    searchData: (_ref) => {\n      let {\n        productCountStart,\n        productCountEnd,\n        category,\n        keyTerm,\n        productColor,\n        section,\n        brand\n      } = _ref,\n          filters = _objectWithoutProperties(_ref, [\"productCountStart\", \"productCountEnd\", \"category\", \"keyTerm\", \"productColor\", \"section\", \"brand\"]);\n\n      let productData;\n      const lastUpdated = getCategoryLastUpdated(affiliateData, section, category) || null;\n      productData = searchPipe(affiliateData, {\n        category,\n        keyTerm,\n        productColor,\n        section,\n        brand\n      });\n      productData = searchResultShapePipe(productData, lastUpdated);\n      productData = filterPipe(productData, filters);\n      productData = productCountPipe(productData, productCountStart, productCountEnd);\n      return {\n        section: 'Search',\n        data: productData\n      };\n    },\n    categoryData: (_ref2) => {\n      let {\n        section,\n        productCountStart,\n        productCountEnd,\n        productType\n      } = _ref2,\n          filters = _objectWithoutProperties(_ref2, [\"section\", \"productCountStart\", \"productCountEnd\", \"productType\"]);\n\n      let productData;\n      productData = categoryPipe(affiliateData, section, productType);\n      productData = filterPipe(productData, filters);\n      productData = productCountPipe(productData, productCountStart, productCountEnd);\n      return {\n        section,\n        data: productData\n      };\n    },\n    affiliateData: () => {\n      return affiliateData;\n    },\n    brandList: () => {\n      const brands = [];\n      traverseAllProducts(affiliateData, {\n        level: 'product',\n        cb: product => {\n          const {\n            brand\n          } = product.metaData;\n          if (!brands.includes(brand)) brands.push(brand);\n        }\n      });\n      return brands;\n    }\n  });\n}","map":{"version":3,"sources":["/Users/justincoulston/Desktop/affilaite-core-mono/packages/app/graphQL/resolvers/productResolver.js"],"names":["MultiString","GraphQLJSON","GraphQLJSONObject","getCategoryLastUpdated","traverseAllProducts","searchPipe","productCountPipe","searchResultShapePipe","categoryPipe","filterPipe","productResolver","affiliateData","scalars","JSON","JSONObject","searchData","productCountStart","productCountEnd","category","keyTerm","productColor","section","brand","filters","productData","lastUpdated","data","categoryData","productType","brandList","brands","level","cb","product","metaData","includes","push"],"mappings":";;;;;;;AACA,SAASA,WAAT,QAA4B,kBAA5B;AAEA,OAAOC,WAAP,IAAsBC,iBAAtB,QAA+C,mBAA/C;AAEA,SAASC,sBAAT,EAAiCC,mBAAjC,QAA4D,UAA5D;AACA,SACEC,UADF,EAEEC,gBAFF,EAGEC,qBAHF,EAIEC,YAJF,EAKEC,UALF,QAMO,iBANP;AAeA,eAAe,SAASC,eAAT,CAAyBC,aAAzB,EAAuE;AACpF,QAAMC,OAAO,GAAG;AACdZ,IAAAA,WADc;AAEda,IAAAA,IAAI,EAAEZ,WAFQ;AAGda,IAAAA,UAAU,EAAEZ;AAHE,GAAhB;AAMA,yCACKU,OADL;AAGEG,IAAAA,UAAU,EAAE,UASsB;AAAA,UATrB;AACXC,QAAAA,iBADW;AAEXC,QAAAA,eAFW;AAGXC,QAAAA,QAHW;AAIXC,QAAAA,OAJW;AAKXC,QAAAA,YALW;AAMXC,QAAAA,OANW;AAOXC,QAAAA;AAPW,OASqB;AAAA,UAD7BC,OAC6B;;AAChC,UAAIC,WAAJ;AACA,YAAMC,WAAW,GAAGtB,sBAAsB,CAACQ,aAAD,EAAgBU,OAAhB,EAAyBH,QAAzB,CAAtB,IAA4D,IAAhF;AAEAM,MAAAA,WAAW,GAAGnB,UAAU,CAAqBM,aAArB,EAAoC;AAC1DO,QAAAA,QAD0D;AAE1DC,QAAAA,OAF0D;AAG1DC,QAAAA,YAH0D;AAI1DC,QAAAA,OAJ0D;AAK1DC,QAAAA;AAL0D,OAApC,CAAxB;AAQAE,MAAAA,WAAW,GAAGjB,qBAAqB,CAAyBiB,WAAzB,EAAsCC,WAAtC,CAAnC;AACAD,MAAAA,WAAW,GAAGf,UAAU,CAAyBe,WAAzB,EAAsCD,OAAtC,CAAxB;AACAC,MAAAA,WAAW,GAAGlB,gBAAgB,CAC5BkB,WAD4B,EAE5BR,iBAF4B,EAG5BC,eAH4B,CAA9B;AAMA,aAAO;AAAEI,QAAAA,OAAO,EAAE,QAAX;AAAqBK,QAAAA,IAAI,EAAEF;AAA3B,OAAP;AACD,KAjCH;AAmCEG,IAAAA,YAAY,EAAE,WAMoB;AAAA,UANnB;AACbN,QAAAA,OADa;AAEbL,QAAAA,iBAFa;AAGbC,QAAAA,eAHa;AAIbW,QAAAA;AAJa,OAMmB;AAAA,UAD7BL,OAC6B;;AAChC,UAAIC,WAAJ;AACAA,MAAAA,WAAW,GAAGhB,YAAY,CAAyBG,aAAzB,EAAwCU,OAAxC,EAAiDO,WAAjD,CAA1B;AACAJ,MAAAA,WAAW,GAAGf,UAAU,CAAyBe,WAAzB,EAAsCD,OAAtC,CAAxB;AAEAC,MAAAA,WAAW,GAAGlB,gBAAgB,CAC5BkB,WAD4B,EAE5BR,iBAF4B,EAG5BC,eAH4B,CAA9B;AAMA,aAAO;AAAEI,QAAAA,OAAF;AAAWK,QAAAA,IAAI,EAAEF;AAAjB,OAAP;AACD,KArDH;AAuDEb,IAAAA,aAAa,EAAE,MAAoB;AACjC,aAAOA,aAAP;AACD,KAzDH;AA2DEkB,IAAAA,SAAS,EAAE,MAAqB;AAC9B,YAAMC,MAAM,GAAG,EAAf;AACA1B,MAAAA,mBAAmB,CAACO,aAAD,EAAgB;AACjCoB,QAAAA,KAAK,EAAE,SAD0B;AAEjCC,QAAAA,EAAE,EAAGC,OAAD,IAA0B;AAC5B,gBAAM;AAAEX,YAAAA;AAAF,cAAYW,OAAO,CAACC,QAA1B;AACA,cAAI,CAACJ,MAAM,CAACK,QAAP,CAAgBb,KAAhB,CAAL,EAA6BQ,MAAM,CAACM,IAAP,CAAYd,KAAZ;AAC9B;AALgC,OAAhB,CAAnB;AAQA,aAAOQ,MAAP;AACD;AAtEH;AAwED","sourcesContent":["//@flow\nimport { MultiString } from '../customScalars';\nimport { type ProductsData, type ProductData, type ProductCategory } from '@types/product';\nimport GraphQLJSON, { GraphQLJSONObject } from 'graphql-type-json';\nimport { type ProductQueryInputArguments } from '../../types/graphQl';\nimport { getCategoryLastUpdated, traverseAllProducts } from './helper';\nimport {\n  searchPipe,\n  productCountPipe,\n  searchResultShapePipe,\n  categoryPipe,\n  filterPipe,\n} from './resolverPipes';\n\ntype ProductResolver = {\n  categoryData: Function,\n  JSON: Object,\n  MultiString: Object,\n  JSONObject: Object,\n};\n\nexport default function productResolver(affiliateData: ProductsData): ProductResolver {\n  const scalars = {\n    MultiString,\n    JSON: GraphQLJSON,\n    JSONObject: GraphQLJSONObject,\n  };\n\n  return {\n    ...scalars,\n\n    searchData: ({\n      productCountStart,\n      productCountEnd,\n      category,\n      keyTerm,\n      productColor,\n      section,\n      brand,\n      ...filters\n    }: ProductQueryInputArguments) => {\n      let productData;\n      const lastUpdated = getCategoryLastUpdated(affiliateData, section, category) || null;\n\n      productData = searchPipe<Array<ProductData>>(affiliateData, {\n        category,\n        keyTerm,\n        productColor,\n        section,\n        brand,\n      });\n\n      productData = searchResultShapePipe<Array<ProductCategory>>(productData, lastUpdated);\n      productData = filterPipe<Array<ProductCategory>>(productData, filters);\n      productData = productCountPipe<Array<ProductCategory>>(\n        productData,\n        productCountStart,\n        productCountEnd\n      );\n\n      return { section: 'Search', data: productData };\n    },\n\n    categoryData: ({\n      section,\n      productCountStart,\n      productCountEnd,\n      productType,\n      ...filters\n    }: ProductQueryInputArguments) => {\n      let productData;\n      productData = categoryPipe<Array<ProductCategory>>(affiliateData, section, productType);\n      productData = filterPipe<Array<ProductCategory>>(productData, filters);\n\n      productData = productCountPipe<Array<ProductCategory>>(\n        productData,\n        productCountStart,\n        productCountEnd\n      );\n\n      return { section, data: productData };\n    },\n\n    affiliateData: (): ProductsData => {\n      return affiliateData;\n    },\n\n    brandList: (): Array<string> => {\n      const brands = [];\n      traverseAllProducts(affiliateData, {\n        level: 'product',\n        cb: (product: ProductData) => {\n          const { brand } = product.metaData;\n          if (!brands.includes(brand)) brands.push(brand);\n        },\n      });\n\n      return brands;\n    },\n  };\n}\n"]},"metadata":{},"sourceType":"module"}