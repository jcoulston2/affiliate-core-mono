{"ast":null,"code":"// TODO: we need to make the redis import work\n// import redis from 'redis';\nimport * as Promise from 'bluebird';\nimport { IS_PROD } from '../../constants';\nimport storeCache from '../../__store-cache__/store-cache.json';\nimport { zipParse } from '../../helpers/common';\n\nclass Store {\n  constructor(data) {\n    this.store = data || null;\n  }\n\n  serialize(data) {\n    return JSON.stringify(data);\n  } // Attempts to build from Redis cloud, if there is no redis store, fallback to\n  // to pre-provided constructor value for store or else give an empty array\n\n\n  async buildStoreFromRedis() {\n    const redisStore = await this.redisGetPromise(this.redisKey);\n    this.store = redisStore ? JSON.parse(redisStore) : this.store || [];\n    return this.store;\n  }\n\n  async connectRedisClient() {\n    this.listenToConnections();\n    this.promisifyRedisMethods();\n    if (this.redisRequireAuth) await this.redisClientAuthPromise(this.redisAuth);\n    return await this.buildStoreFromRedis();\n  }\n\n  async flush() {\n    await this.redisFlushPromise(this.redisKey);\n    const checkFlushed = await this.redisGetPromise(this.redisKey);\n    if (!checkFlushed) console.log(`FLUSHED ${this.redisKey}`);\n  }\n\n  async setStore(affiliateData) {\n    this.store = affiliateData;\n\n    try {\n      if (this.redisClient) {\n        await this.redisSetPromise(this.redisKey, this.serialize(affiliateData));\n      }\n\n      return {\n        success: true\n      };\n    } catch (e) {\n      return {\n        success: false,\n        error: `${e}`\n      };\n    }\n  } // Redis only\n\n\n  async getRedisStore() {\n    const store = await this.redisGetPromise(this.redisKey);\n    return JSON.parse(store);\n  } // Redis only\n\n\n  getStore() {\n    return this.store;\n  }\n\n}\n\nconst configuredStore = new Store(zipParse(storeCache.store), {\n  useRedis: false\n});\nexport { configuredStore, Store };","map":{"version":3,"sources":["/Users/justincoulston/Desktop/affilaite-core-mono/packages/affiliate-app/server/store/Store.js"],"names":["Promise","IS_PROD","storeCache","zipParse","Store","constructor","data","store","serialize","JSON","stringify","buildStoreFromRedis","redisStore","redisGetPromise","redisKey","parse","connectRedisClient","listenToConnections","promisifyRedisMethods","redisRequireAuth","redisClientAuthPromise","redisAuth","flush","redisFlushPromise","checkFlushed","console","log","setStore","affiliateData","redisClient","redisSetPromise","success","e","error","getRedisStore","getStore","configuredStore","useRedis"],"mappings":"AAEA;AACA;AACA,OAAO,KAAKA,OAAZ,MAAyB,UAAzB;AACA,SAASC,OAAT,QAAwB,iBAAxB;AACA,OAAOC,UAAP,MAAuB,wCAAvB;AACA,SAASC,QAAT,QAAyB,sBAAzB;;AAOA,MAAMC,KAAN,CAAY;AAGVC,EAAAA,WAAW,CAACC,IAAD,EAAkB;AAC3B,SAAKC,KAAL,GAAaD,IAAI,IAAI,IAArB;AACD;;AAEDE,EAAAA,SAAS,CAACF,IAAD,EAAuB;AAC9B,WAAOG,IAAI,CAACC,SAAL,CAAeJ,IAAf,CAAP;AACD,GATS,CAWV;AACA;;;AACA,QAAMK,mBAAN,GAAkD;AAChD,UAAMC,UAAU,GAAG,MAAM,KAAKC,eAAL,CAAmC,KAAKC,QAAxC,CAAzB;AACA,SAAKP,KAAL,GAAaK,UAAU,GAAGH,IAAI,CAACM,KAAL,CAAWH,UAAX,CAAH,GAA4B,KAAKL,KAAL,IAAc,EAAjE;AACA,WAAO,KAAKA,KAAZ;AACD;;AAED,QAAMS,kBAAN,GAAiD;AAC/C,SAAKC,mBAAL;AACA,SAAKC,qBAAL;AACA,QAAI,KAAKC,gBAAT,EAA2B,MAAM,KAAKC,sBAAL,CAA0C,KAAKC,SAA/C,CAAN;AAC3B,WAAO,MAAM,KAAKV,mBAAL,EAAb;AACD;;AAED,QAAMW,KAAN,GAA4B;AAC1B,UAAM,KAAKC,iBAAL,CAAuB,KAAKT,QAA5B,CAAN;AACA,UAAMU,YAAY,GAAG,MAAM,KAAKX,eAAL,CAAmC,KAAKC,QAAxC,CAA3B;AACA,QAAI,CAACU,YAAL,EAAmBC,OAAO,CAACC,GAAR,CAAa,WAAU,KAAKZ,QAAS,EAArC;AACpB;;AAED,QAAMa,QAAN,CACEC,aADF,EAEiD;AAC/C,SAAKrB,KAAL,GAAaqB,aAAb;;AAEA,QAAI;AACF,UAAI,KAAKC,WAAT,EAAsB;AACpB,cAAM,KAAKC,eAAL,CAAmC,KAAKhB,QAAxC,EAAkD,KAAKN,SAAL,CAAeoB,aAAf,CAAlD,CAAN;AACD;;AACD,aAAO;AACLG,QAAAA,OAAO,EAAE;AADJ,OAAP;AAGD,KAPD,CAOE,OAAOC,CAAP,EAAU;AACV,aAAO;AACLD,QAAAA,OAAO,EAAE,KADJ;AAELE,QAAAA,KAAK,EAAG,GAAED,CAAE;AAFP,OAAP;AAID;AACF,GAlDS,CAoDV;;;AACA,QAAME,aAAN,GAA4C;AAC1C,UAAM3B,KAAK,GAAG,MAAM,KAAKM,eAAL,CAAmC,KAAKC,QAAxC,CAApB;AACA,WAAOL,IAAI,CAACM,KAAL,CAAWR,KAAX,CAAP;AACD,GAxDS,CA0DV;;;AACA4B,EAAAA,QAAQ,GAAyB;AAC/B,WAAO,KAAK5B,KAAZ;AACD;;AA7DS;;AAgEZ,MAAM6B,eAAe,GAAG,IAAIhC,KAAJ,CAAUD,QAAQ,CAACD,UAAU,CAACK,KAAZ,CAAlB,EAAsC;AAAE8B,EAAAA,QAAQ,EAAE;AAAZ,CAAtC,CAAxB;AAEA,SAASD,eAAT,EAA0BhC,KAA1B","sourcesContent":["//@flow\n\n// TODO: we need to make the redis import work\n// import redis from 'redis';\nimport * as Promise from 'bluebird';\nimport { IS_PROD } from '../../constants';\nimport storeCache from '../../__store-cache__/store-cache.json';\nimport { zipParse } from '../../helpers/common';\nimport { type ParsedStore } from '../../types/store';\n\ntype StoreConfig = {\n  useRedis: boolean,\n};\n\nclass Store {\n  store: Array<any> | Object;\n\n  constructor(data: any): void {\n    this.store = data || null;\n  }\n\n  serialize(data: Object): string {\n    return JSON.stringify(data);\n  }\n\n  // Attempts to build from Redis cloud, if there is no redis store, fallback to\n  // to pre-provided constructor value for store or else give an empty array\n  async buildStoreFromRedis(): Promise<ParsedStore> {\n    const redisStore = await this.redisGetPromise<Promise<any>>(this.redisKey);\n    this.store = redisStore ? JSON.parse(redisStore) : this.store || [];\n    return this.store;\n  }\n\n  async connectRedisClient(): Promise<ParsedStore> {\n    this.listenToConnections();\n    this.promisifyRedisMethods();\n    if (this.redisRequireAuth) await this.redisClientAuthPromise<Promise<any>>(this.redisAuth);\n    return await this.buildStoreFromRedis();\n  }\n\n  async flush(): Promise<any> {\n    await this.redisFlushPromise(this.redisKey);\n    const checkFlushed = await this.redisGetPromise<Promise<any>>(this.redisKey);\n    if (!checkFlushed) console.log(`FLUSHED ${this.redisKey}`);\n  }\n\n  async setStore(\n    affiliateData: Array<any> | Object\n  ): Promise<{ success: boolean, error?: string }> {\n    this.store = affiliateData;\n\n    try {\n      if (this.redisClient) {\n        await this.redisSetPromise<Promise<any>>(this.redisKey, this.serialize(affiliateData));\n      }\n      return {\n        success: true,\n      };\n    } catch (e) {\n      return {\n        success: false,\n        error: `${e}`,\n      };\n    }\n  }\n\n  // Redis only\n  async getRedisStore(): Promise<ParsedStore> {\n    const store = await this.redisGetPromise<Promise<any>>(this.redisKey);\n    return JSON.parse(store);\n  }\n\n  // Redis only\n  getStore(): Promise<ParsedStore> {\n    return this.store;\n  }\n}\n\nconst configuredStore = new Store(zipParse(storeCache.store), { useRedis: false });\n\nexport { configuredStore, Store };\n"]},"metadata":{},"sourceType":"module"}