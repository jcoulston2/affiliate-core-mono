{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/extends\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nvar _jsxFileName = \"/Users/justincoulston/Desktop/affilaite-core-mono/packages/affiliate-app/components/units/Flicker/Flicker.js\";\nvar __jsx = React.createElement;\nimport React, { useEffect } from 'react';\nimport { getNode } from '@helpers/common';\nimport { FlickAnimationsProvider, FlickCard, FlickCardInner, CardContainer, AnimationContainer } from './styles';\nimport { selectors } from './helper';\n// IMPORTANT NOTE: normally handling logic via query selectors with React components does not sit well in most cases,\n// often this can lead to re-rendering confusion as well as convoluted logic. In the below, there are examples of using query\n// selectors - the reason for this is to make transitions as smooth as possible and to avoid 'glitching / jerking' caused by\n// component re-renders. The card animations are handled via an external library. Becasue we have so many product cards stacked\n// on top of each other with all their held product information, passing through a large data map of products causes some\n// performance issues as well as UX / UI issues. The library does not handle these performance issues and only works on a\n// card by card basis. Rather than rendering all the products, we only 'show' the relevant product when it's next in the list.\n// We do this via query selectors and CSS to make the transitions as smooth as possible.\nlet lastCardIndexSwiped = null;\nlet flickUrlTracker = null;\nexport default function Flicker(_ref) {\n  let {\n    dataMap,\n    Component,\n    onEndCallback,\n    onSwipeCallback,\n    SwipeIconUp,\n    SwipeIconDown,\n    SwipeIconLeft,\n    SwipeIconRight\n  } = _ref,\n      rest = _objectWithoutProperties(_ref, [\"dataMap\", \"Component\", \"onEndCallback\", \"onSwipeCallback\", \"SwipeIconUp\", \"SwipeIconDown\", \"SwipeIconLeft\", \"SwipeIconRight\"]);\n\n  const handleAnimationEffect = direction => {\n    var _getNode, _getNode2;\n\n    const animationContainerSelector = selectors.animationContainer();\n    const animationIcon = selectors.animationIcon(direction);\n    (_getNode = getNode(animationIcon)) === null || _getNode === void 0 ? void 0 : _getNode.classList.add('icon-show');\n    (_getNode2 = getNode(animationContainerSelector)) === null || _getNode2 === void 0 ? void 0 : _getNode2.classList.add('pulse');\n    setTimeout(() => {\n      var _getNode3, _getNode4;\n\n      (_getNode3 = getNode(animationIcon)) === null || _getNode3 === void 0 ? void 0 : _getNode3.classList.remove('icon-show');\n      (_getNode4 = getNode(animationContainerSelector)) === null || _getNode4 === void 0 ? void 0 : _getNode4.classList.remove('pulse');\n    }, 501);\n  };\n\n  const setLastCardIndexSwiped = index => {\n    lastCardIndexSwiped = index;\n  };\n\n  const getNodeByIndex = index => {\n    const selector = selectors.cardNode(index);\n    return getNode(selector);\n  };\n\n  const handleRevealCards = index => {\n    const revealCardNodes = getNodeByIndex(index);\n    if (revealCardNodes) revealCardNodes.style.display = 'block';\n  };\n\n  const resetCardIndex = () => {\n    lastCardIndexSwiped = null;\n  };\n\n  const setUrlTracker = plpUrl => {\n    flickUrlTracker = plpUrl;\n  };\n\n  const handleCardsReset = () => {\n    const plpUrl = window.location.href;\n\n    if (!flickUrlTracker) {\n      setUrlTracker(plpUrl);\n    } else if (plpUrl !== flickUrlTracker) {\n      resetCardIndex();\n      setUrlTracker(plpUrl);\n    }\n  };\n\n  const swiped = (direction, dataItem, index) => {\n    const nextCard = index + 1;\n\n    if (index >= dataMap.length && onEndCallback) {\n      return onEndCallback();\n    } else {\n      handleAnimationEffect(direction);\n      handleRevealCards(nextCard);\n      setLastCardIndexSwiped(nextCard);\n      onSwipeCallback(direction, dataItem);\n    }\n  };\n\n  useEffect(() => {\n    const nextCard = lastCardIndexSwiped + 1;\n    handleRevealCards(nextCard);\n  }, [dataMap.length]);\n  handleCardsReset();\n  return __jsx(CardContainer, {\n    \"data-ref\": \"card-container\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 112,\n      columnNumber: 5\n    }\n  }, dataMap.map((dataItem, index) => {\n    const nodeIndex = index + 1;\n    return __jsx(FlickCard, _extends({\n      key: index,\n      onSwipe: dir => swiped(dir, dataItem, nodeIndex),\n      preventSwipe: ['down']\n    }, rest, {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 116,\n        columnNumber: 11\n      }\n    }), __jsx(FlickCardInner, {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 121,\n        columnNumber: 13\n      }\n    }, __jsx(Component.type, _extends({}, Component.props, dataItem, {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 122,\n        columnNumber: 15\n      }\n    }))));\n  }), __jsx(FlickAnimationsProvider, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 127,\n      columnNumber: 7\n    }\n  }), __jsx(AnimationContainer, {\n    \"data-ref\": \"animation-container\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 128,\n      columnNumber: 7\n    }\n  }, SwipeIconUp && __jsx(SwipeIconUp.type, _extends({}, SwipeIconUp.props, {\n    \"data-ref\": \"up\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 129,\n      columnNumber: 25\n    }\n  })), SwipeIconDown && __jsx(SwipeIconDown.type, _extends({}, SwipeIconDown.props, {\n    \"data-ref\": \"down\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 130,\n      columnNumber: 27\n    }\n  })), SwipeIconLeft && __jsx(SwipeIconLeft.type, _extends({}, SwipeIconLeft.props, {\n    \"data-ref\": \"left\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 131,\n      columnNumber: 27\n    }\n  })), SwipeIconRight && __jsx(SwipeIconRight.type, _extends({}, SwipeIconRight.props, {\n    \"data-ref\": \"right\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 132,\n      columnNumber: 28\n    }\n  }))));\n}","map":{"version":3,"sources":["/Users/justincoulston/Desktop/affilaite-core-mono/packages/affiliate-app/components/units/Flicker/Flicker.js"],"names":["React","useEffect","getNode","FlickAnimationsProvider","FlickCard","FlickCardInner","CardContainer","AnimationContainer","selectors","lastCardIndexSwiped","flickUrlTracker","Flicker","dataMap","Component","onEndCallback","onSwipeCallback","SwipeIconUp","SwipeIconDown","SwipeIconLeft","SwipeIconRight","rest","handleAnimationEffect","direction","animationContainerSelector","animationContainer","animationIcon","classList","add","setTimeout","remove","setLastCardIndexSwiped","index","getNodeByIndex","selector","cardNode","handleRevealCards","revealCardNodes","style","display","resetCardIndex","setUrlTracker","plpUrl","handleCardsReset","window","location","href","swiped","dataItem","nextCard","length","map","nodeIndex","dir","props"],"mappings":"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","sourcesContent":["//@flow\nimport React, { useEffect } from 'react';\nimport { type ReactComponent } from '@types/react';\nimport { getNode } from '@helpers/common';\nimport {\n  FlickAnimationsProvider,\n  FlickCard,\n  FlickCardInner,\n  CardContainer,\n  AnimationContainer,\n} from './styles';\nimport { selectors } from './helper';\n\ntype FlickerProps = $Exact<{\n  onEndCallback: Function,\n  onSwipeCallback: Function,\n  SwipeIconUp?: ReactComponent,\n  SwipeIconDown?: ReactComponent,\n  SwipeIconLeft?: ReactComponent,\n  SwipeIconRight?: ReactComponent,\n  Component: ReactComponent,\n  dataMap: Array<Object>,\n  ...\n}>;\n\ntype FlickerDirection = 'up' | 'down' | 'left' | 'right';\n\n// IMPORTANT NOTE: normally handling logic via query selectors with React components does not sit well in most cases,\n// often this can lead to re-rendering confusion as well as convoluted logic. In the below, there are examples of using query\n// selectors - the reason for this is to make transitions as smooth as possible and to avoid 'glitching / jerking' caused by\n// component re-renders. The card animations are handled via an external library. Becasue we have so many product cards stacked\n// on top of each other with all their held product information, passing through a large data map of products causes some\n// performance issues as well as UX / UI issues. The library does not handle these performance issues and only works on a\n// card by card basis. Rather than rendering all the products, we only 'show' the relevant product when it's next in the list.\n// We do this via query selectors and CSS to make the transitions as smooth as possible.\nlet lastCardIndexSwiped = null;\nlet flickUrlTracker = null;\nexport default function Flicker({\n  dataMap,\n  Component,\n  onEndCallback,\n  onSwipeCallback,\n  SwipeIconUp,\n  SwipeIconDown,\n  SwipeIconLeft,\n  SwipeIconRight,\n  ...rest\n}: FlickerProps) {\n  const handleAnimationEffect = (direction: FlickerDirection): void => {\n    const animationContainerSelector = selectors.animationContainer();\n    const animationIcon = selectors.animationIcon(direction);\n    getNode(animationIcon)?.classList.add('icon-show');\n    getNode(animationContainerSelector)?.classList.add('pulse');\n    setTimeout(() => {\n      getNode(animationIcon)?.classList.remove('icon-show');\n      getNode(animationContainerSelector)?.classList.remove('pulse');\n    }, 501);\n  };\n\n  const setLastCardIndexSwiped = (index: number): void => {\n    lastCardIndexSwiped = index;\n  };\n\n  const getNodeByIndex = (index: number): any => {\n    const selector = selectors.cardNode(index);\n    return getNode(selector);\n  };\n\n  const handleRevealCards = (index: number): any => {\n    const revealCardNodes = getNodeByIndex(index);\n    if (revealCardNodes) revealCardNodes.style.display = 'block';\n  };\n\n  const resetCardIndex = (): void => {\n    lastCardIndexSwiped = null;\n  };\n\n  const setUrlTracker = (plpUrl: string): void => {\n    flickUrlTracker = plpUrl;\n  };\n\n  const handleCardsReset = (): void => {\n    const plpUrl = window.location.href;\n    if (!flickUrlTracker) {\n      setUrlTracker(plpUrl);\n    } else if (plpUrl !== flickUrlTracker) {\n      resetCardIndex();\n      setUrlTracker(plpUrl);\n    }\n  };\n\n  const swiped = (direction: FlickerDirection, dataItem: Array<Object>, index: number): void => {\n    const nextCard = index + 1;\n    if (index >= dataMap.length && onEndCallback) {\n      return onEndCallback();\n    } else {\n      handleAnimationEffect(direction);\n      handleRevealCards(nextCard);\n      setLastCardIndexSwiped(nextCard);\n      onSwipeCallback(direction, dataItem);\n    }\n  };\n\n  useEffect(() => {\n    const nextCard = lastCardIndexSwiped + 1;\n    handleRevealCards(nextCard);\n  }, [dataMap.length]);\n\n  handleCardsReset();\n\n  return (\n    <CardContainer data-ref=\"card-container\">\n      {dataMap.map((dataItem, index) => {\n        const nodeIndex = index + 1;\n        return (\n          <FlickCard\n            key={index}\n            onSwipe={(dir) => swiped(dir, dataItem, nodeIndex)}\n            preventSwipe={['down']}\n            {...rest}>\n            <FlickCardInner>\n              <Component.type {...Component.props} {...dataItem} />\n            </FlickCardInner>\n          </FlickCard>\n        );\n      })}\n      <FlickAnimationsProvider />\n      <AnimationContainer data-ref=\"animation-container\">\n        {SwipeIconUp && <SwipeIconUp.type {...SwipeIconUp.props} data-ref=\"up\" />}\n        {SwipeIconDown && <SwipeIconDown.type {...SwipeIconDown.props} data-ref=\"down\" />}\n        {SwipeIconLeft && <SwipeIconLeft.type {...SwipeIconLeft.props} data-ref=\"left\" />}\n        {SwipeIconRight && <SwipeIconRight.type {...SwipeIconRight.props} data-ref=\"right\" />}\n      </AnimationContainer>\n    </CardContainer>\n  );\n}\n"]},"metadata":{},"sourceType":"module"}