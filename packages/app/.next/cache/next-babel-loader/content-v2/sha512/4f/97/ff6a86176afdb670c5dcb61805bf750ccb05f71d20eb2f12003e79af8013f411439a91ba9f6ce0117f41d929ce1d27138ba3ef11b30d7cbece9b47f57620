{"ast":null,"code":"import { urlCaseMatches } from '@helpers/common';\nimport { getSingle } from '@helpers/common';\nexport function getSection(affiliateData, section) {\n  var _affiliateData$find;\n\n  return (affiliateData === null || affiliateData === void 0 ? void 0 : (_affiliateData$find = affiliateData.find(category => urlCaseMatches(category.section, section))) === null || _affiliateData$find === void 0 ? void 0 : _affiliateData$find.data) || [];\n}\nexport function getCategory(affiliateData, section, category) {\n  const sec = getSection(affiliateData, section);\n\n  if (Array.isArray(category)) {\n    let catDataArray = [];\n\n    for (const categoryFilter of category) {\n      var _sec$find;\n\n      const categoryFilterData = (sec === null || sec === void 0 ? void 0 : (_sec$find = sec.find(item => urlCaseMatches(item.category, categoryFilter))) === null || _sec$find === void 0 ? void 0 : _sec$find.data) || [];\n      catDataArray = [...catDataArray, ...categoryFilterData];\n    }\n\n    return catDataArray;\n  } else {\n    var _sec$find2;\n\n    return (sec === null || sec === void 0 ? void 0 : (_sec$find2 = sec.find(item => urlCaseMatches(item.category, category))) === null || _sec$find2 === void 0 ? void 0 : _sec$find2.data) || [];\n  }\n}\nexport function getCategoryLastUpdated(affiliateData, section, category) {\n  const sec = getSection(affiliateData, section);\n  const data = sec === null || sec === void 0 ? void 0 : sec.find(item => urlCaseMatches(item.category, getSingle(category)));\n  return data === null || data === void 0 ? void 0 : data.categoryLastUpdated;\n}\nexport function eachCategoryCb(affiliateData, section, cb) {\n  const sec = getSection(affiliateData, section);\n\n  for (const cat of sec) {\n    cb(cat);\n  }\n}\nexport function traverseProductsByCategory(affiliateData, section, category, callback) {\n  const cat = getCategory(affiliateData, section, category);\n\n  for (const product of cat) {\n    callback(product);\n  }\n}\nexport function traverseProductsBySection(affiliateData, section, callback) {\n  const sec = getSection(affiliateData, section);\n  const {\n    level,\n    cb\n  } = callback;\n\n  for (const cat of sec) {\n    if (level === 'category') cb(cat);\n\n    for (const product of cat.data) {\n      if (level === 'product') cb(product);\n    }\n  }\n}\nexport function traverseAllProducts(affiliateData, callback) {\n  const {\n    level,\n    cb\n  } = callback;\n\n  for (const sec of affiliateData) {\n    if (level === 'section') cb(sec);\n\n    for (const cat of sec.data) {\n      if (level === 'category') cb(cat);\n\n      for (const product of cat.data) {\n        if (level === 'product') cb(product);\n      }\n    }\n  }\n}\nexport function simpleSearchMatcher(tags, keyTerm) {\n  if (!(tags !== null && tags !== void 0 && tags.length)) return false;\n  const tagsRx = new RegExp(`\\\\b(${tags.join('|')})\\\\b`, 'gi');\n  const keyTermMatch = keyTerm.match(tagsRx);\n  const leastMatchesToQualifySearch = 2;\n  return !!(keyTermMatch && (keyTermMatch === null || keyTermMatch === void 0 ? void 0 : keyTermMatch.length) >= leastMatchesToQualifySearch);\n}","map":{"version":3,"sources":["/Users/justincoulston/Desktop/affilaite-core-mono/packages/affiliate-app/graphQL/resolvers/helper.js"],"names":["urlCaseMatches","getSingle","getSection","affiliateData","section","find","category","data","getCategory","sec","Array","isArray","catDataArray","categoryFilter","categoryFilterData","item","getCategoryLastUpdated","categoryLastUpdated","eachCategoryCb","cb","cat","traverseProductsByCategory","callback","product","traverseProductsBySection","level","traverseAllProducts","simpleSearchMatcher","tags","keyTerm","length","tagsRx","RegExp","join","keyTermMatch","match","leastMatchesToQualifySearch"],"mappings":"AAEA,SAASA,cAAT,QAA+B,iBAA/B;AACA,SAASC,SAAT,QAA0B,iBAA1B;AAEA,OAAO,SAASC,UAAT,CAAoBC,aAApB,EAAiDC,OAAjD,EAA0F;AAAA;;AAC/F,SAAO,CAAAD,aAAa,SAAb,IAAAA,aAAa,WAAb,mCAAAA,aAAa,CAAEE,IAAf,CAAqBC,QAAD,IAAcN,cAAc,CAACM,QAAQ,CAACF,OAAV,EAAmBA,OAAnB,CAAhD,6EAA8EG,IAA9E,KAAsF,EAA7F;AACD;AAED,OAAO,SAASC,WAAT,CACLL,aADK,EAELC,OAFK,EAGLE,QAHK,EAIe;AACpB,QAAMG,GAAG,GAAGP,UAAU,CAACC,aAAD,EAAgBC,OAAhB,CAAtB;;AACA,MAAIM,KAAK,CAACC,OAAN,CAAcL,QAAd,CAAJ,EAA6B;AAC3B,QAAIM,YAAY,GAAG,EAAnB;;AACA,SAAK,MAAMC,cAAX,IAA6BP,QAA7B,EAAuC;AAAA;;AACrC,YAAMQ,kBAAkB,GACtB,CAAAL,GAAG,SAAH,IAAAA,GAAG,WAAH,yBAAAA,GAAG,CAAEJ,IAAL,CAAWU,IAAD,IAAUf,cAAc,CAACe,IAAI,CAACT,QAAN,EAAgBO,cAAhB,CAAlC,yDAAoEN,IAApE,KAA4E,EAD9E;AAEAK,MAAAA,YAAY,GAAG,CAAC,GAAGA,YAAJ,EAAkB,GAAGE,kBAArB,CAAf;AACD;;AACD,WAAOF,YAAP;AACD,GARD,MAQO;AAAA;;AACL,WAAO,CAAAH,GAAG,SAAH,IAAAA,GAAG,WAAH,0BAAAA,GAAG,CAAEJ,IAAL,CAAWU,IAAD,IAAUf,cAAc,CAACe,IAAI,CAACT,QAAN,EAAgBA,QAAhB,CAAlC,2DAA8DC,IAA9D,KAAsE,EAA7E;AACD;AACF;AAED,OAAO,SAASS,sBAAT,CACLb,aADK,EAELC,OAFK,EAGLE,QAHK,EAII;AACT,QAAMG,GAAG,GAAGP,UAAU,CAACC,aAAD,EAAgBC,OAAhB,CAAtB;AACA,QAAMG,IAAI,GAAGE,GAAH,aAAGA,GAAH,uBAAGA,GAAG,CAAEJ,IAAL,CAAWU,IAAD,IAAUf,cAAc,CAACe,IAAI,CAACT,QAAN,EAAgBL,SAAS,CAACK,QAAD,CAAzB,CAAlC,CAAb;AACA,SAAOC,IAAP,aAAOA,IAAP,uBAAOA,IAAI,CAAEU,mBAAb;AACD;AAED,OAAO,SAASC,cAAT,CAAwBf,aAAxB,EAAqDC,OAArD,EAAsEe,EAAtE,EAA0F;AAC/F,QAAMV,GAAG,GAAGP,UAAU,CAACC,aAAD,EAAgBC,OAAhB,CAAtB;;AACA,OAAK,MAAMgB,GAAX,IAAkBX,GAAlB,EAAuB;AACrBU,IAAAA,EAAE,CAACC,GAAD,CAAF;AACD;AACF;AAED,OAAO,SAASC,0BAAT,CACLlB,aADK,EAELC,OAFK,EAGLE,QAHK,EAILgB,QAJK,EAKC;AACN,QAAMF,GAAG,GAAGZ,WAAW,CAACL,aAAD,EAAgBC,OAAhB,EAAyBE,QAAzB,CAAvB;;AACA,OAAK,MAAMiB,OAAX,IAAsBH,GAAtB,EAA2B;AACzBE,IAAAA,QAAQ,CAACC,OAAD,CAAR;AACD;AACF;AAED,OAAO,SAASC,yBAAT,CACLrB,aADK,EAELC,OAFK,EAGLkB,QAHK,EAIC;AACN,QAAMb,GAAG,GAAGP,UAAU,CAACC,aAAD,EAAgBC,OAAhB,CAAtB;AACA,QAAM;AAAEqB,IAAAA,KAAF;AAASN,IAAAA;AAAT,MAAgBG,QAAtB;;AACA,OAAK,MAAMF,GAAX,IAAkBX,GAAlB,EAAuB;AACrB,QAAIgB,KAAK,KAAK,UAAd,EAA0BN,EAAE,CAACC,GAAD,CAAF;;AAC1B,SAAK,MAAMG,OAAX,IAAsBH,GAAG,CAACb,IAA1B,EAAgC;AAC9B,UAAIkB,KAAK,KAAK,SAAd,EAAyBN,EAAE,CAACI,OAAD,CAAF;AAC1B;AACF;AACF;AAED,OAAO,SAASG,mBAAT,CAA6BvB,aAA7B,EAA0DmB,QAA1D,EAA8E;AACnF,QAAM;AAAEG,IAAAA,KAAF;AAASN,IAAAA;AAAT,MAAgBG,QAAtB;;AACA,OAAK,MAAMb,GAAX,IAAkBN,aAAlB,EAAiC;AAC/B,QAAIsB,KAAK,KAAK,SAAd,EAAyBN,EAAE,CAACV,GAAD,CAAF;;AACzB,SAAK,MAAMW,GAAX,IAAkBX,GAAG,CAACF,IAAtB,EAA4B;AAC1B,UAAIkB,KAAK,KAAK,UAAd,EAA0BN,EAAE,CAACC,GAAD,CAAF;;AAC1B,WAAK,MAAMG,OAAX,IAAsBH,GAAG,CAACb,IAA1B,EAAgC;AAC9B,YAAIkB,KAAK,KAAK,SAAd,EAAyBN,EAAE,CAACI,OAAD,CAAF;AAC1B;AACF;AACF;AACF;AAED,OAAO,SAASI,mBAAT,CAA6BC,IAA7B,EAAkDC,OAAlD,EAA4E;AACjF,MAAI,EAACD,IAAD,aAACA,IAAD,eAACA,IAAI,CAAEE,MAAP,CAAJ,EAAmB,OAAO,KAAP;AACnB,QAAMC,MAAM,GAAG,IAAIC,MAAJ,CAAY,OAAMJ,IAAI,CAACK,IAAL,CAAU,GAAV,CAAe,MAAjC,EAAwC,IAAxC,CAAf;AACA,QAAMC,YAAY,GAAGL,OAAO,CAACM,KAAR,CAAcJ,MAAd,CAArB;AACA,QAAMK,2BAA2B,GAAG,CAApC;AAEA,SAAO,CAAC,EAAEF,YAAY,IAAI,CAAAA,YAAY,SAAZ,IAAAA,YAAY,WAAZ,YAAAA,YAAY,CAAEJ,MAAd,KAAwBM,2BAA1C,CAAR;AACD","sourcesContent":["//@flow\nimport { type ProductCategory, type ProductsData, type ProductData } from '../../types/product';\nimport { urlCaseMatches } from '@helpers/common';\nimport { getSingle } from '@helpers/common';\n\nexport function getSection(affiliateData: ProductsData, section: string): Array<ProductCategory> {\n  return affiliateData?.find((category) => urlCaseMatches(category.section, section))?.data || [];\n}\n\nexport function getCategory(\n  affiliateData: ProductsData,\n  section: string,\n  category: string\n): Array<ProductData> {\n  const sec = getSection(affiliateData, section);\n  if (Array.isArray(category)) {\n    let catDataArray = [];\n    for (const categoryFilter of category) {\n      const categoryFilterData =\n        sec?.find((item) => urlCaseMatches(item.category, categoryFilter))?.data || [];\n      catDataArray = [...catDataArray, ...categoryFilterData];\n    }\n    return catDataArray;\n  } else {\n    return sec?.find((item) => urlCaseMatches(item.category, category))?.data || [];\n  }\n}\n\nexport function getCategoryLastUpdated(\n  affiliateData: ProductsData,\n  section: string,\n  category: string\n): ?string {\n  const sec = getSection(affiliateData, section);\n  const data = sec?.find((item) => urlCaseMatches(item.category, getSingle(category)));\n  return data?.categoryLastUpdated;\n}\n\nexport function eachCategoryCb(affiliateData: ProductsData, section: string, cb: Function): void {\n  const sec = getSection(affiliateData, section);\n  for (const cat of sec) {\n    cb(cat);\n  }\n}\n\nexport function traverseProductsByCategory(\n  affiliateData: ProductsData,\n  section: string,\n  category: string,\n  callback: Function\n): void {\n  const cat = getCategory(affiliateData, section, category);\n  for (const product of cat) {\n    callback(product);\n  }\n}\n\nexport function traverseProductsBySection(\n  affiliateData: ProductsData,\n  section: string,\n  callback: Function\n): void {\n  const sec = getSection(affiliateData, section);\n  const { level, cb } = callback;\n  for (const cat of sec) {\n    if (level === 'category') cb(cat);\n    for (const product of cat.data) {\n      if (level === 'product') cb(product);\n    }\n  }\n}\n\nexport function traverseAllProducts(affiliateData: ProductsData, callback: Function) {\n  const { level, cb } = callback;\n  for (const sec of affiliateData) {\n    if (level === 'section') cb(sec);\n    for (const cat of sec.data) {\n      if (level === 'category') cb(cat);\n      for (const product of cat.data) {\n        if (level === 'product') cb(product);\n      }\n    }\n  }\n}\n\nexport function simpleSearchMatcher(tags: Array<string>, keyTerm: string): boolean {\n  if (!tags?.length) return false;\n  const tagsRx = new RegExp(`\\\\b(${tags.join('|')})\\\\b`, 'gi');\n  const keyTermMatch = keyTerm.match(tagsRx);\n  const leastMatchesToQualifySearch = 2;\n\n  return !!(keyTermMatch && keyTermMatch?.length >= leastMatchesToQualifySearch);\n}\n"]},"metadata":{},"sourceType":"module"}