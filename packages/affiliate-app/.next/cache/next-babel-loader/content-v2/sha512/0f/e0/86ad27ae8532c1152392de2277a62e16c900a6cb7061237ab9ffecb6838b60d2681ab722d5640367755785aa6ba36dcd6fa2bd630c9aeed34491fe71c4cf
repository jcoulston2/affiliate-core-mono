{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport { deDupeArray, urlCase } from '@helpers/common';\nimport { SEARCH_PATH } from '@constants';\nexport function addUrlPart(name, value, partsArray) {\n  // remove any existing params for a given name to be overwritten\n  const parts = partsArray.filter(item => item && !item.includes(name));\n  parts.push(`${name}=${value}`);\n  return parts;\n}\nexport function addExistingUrlParts(productUrl, productUrlParams) {\n  if (!productUrl) return [];\n  const query = productUrlParams === null || productUrlParams === void 0 ? void 0 : productUrlParams.search;\n  return (query === null || query === void 0 ? void 0 : query.replace(/^\\?/, '').split('&')) || [];\n}\nexport function createUrlFilters({\n  priceSort,\n  priceThresholdLow,\n  priceThresholdHigh,\n  keyWords,\n  saleThreshold,\n  brands,\n  section,\n  category\n}, productUrl, isSearchPage) {\n  const origin = window.location.origin;\n  const productUrlParams = new URL(`${origin}${productUrl}`);\n  const productUrlPath = productUrlParams.pathname;\n  const queryJoiner = isSearchPage ? '?' : '';\n  let urlParts = addExistingUrlParts(productUrl, productUrlParams);\n\n  if (priceSort) {\n    urlParts = addUrlPart('price-sort', priceSort, urlParts);\n  }\n\n  if (priceThresholdLow) {\n    urlParts = addUrlPart('price-threshold-low', priceThresholdLow, urlParts);\n  }\n\n  if (priceThresholdHigh) {\n    urlParts = addUrlPart('price-threshold-high', priceThresholdHigh, urlParts);\n  }\n\n  if (keyWords !== null && keyWords !== void 0 && keyWords.length) {\n    urlParts = addUrlPart('key-words', keyWords.join(','), urlParts);\n  }\n\n  if (brands !== null && brands !== void 0 && brands.length) {\n    urlParts = addUrlPart('brands', brands.join(','), urlParts);\n  }\n\n  if (saleThreshold && parseInt(saleThreshold)) {\n    urlParts = addUrlPart('sale-threshold', saleThreshold, urlParts);\n  }\n\n  if (category !== null && category !== void 0 && category.length) {\n    urlParts = addUrlPart('category', category.join(','), urlParts);\n  }\n\n  if (section) {\n    urlParts = addUrlPart('section', section, urlParts);\n  }\n\n  const filterPath = urlParts.length ? `${urlParts.join('&')}` : '';\n  window.history.replaceState({}, null, `${productUrlPath}${queryJoiner}${filterPath}`);\n}\nexport function normalizeFilters({\n  priceSort,\n  priceThreshold,\n  keyWords,\n  saleThreshold,\n  scaler,\n  hasTouchedSlider,\n  brands,\n  section,\n  category\n}, isSearchPage) {\n  const [min, max] = priceThreshold;\n  const isMinSetting = min === 0;\n  const isMaxSetting = max === 100;\n  const minPrice = hasTouchedSlider && !isMinSetting ? min * scaler : null;\n  const maxPrice = hasTouchedSlider && !isMaxSetting ? max * scaler : null;\n  const searchSpecificFilters = isSearchPage ? {\n    section,\n    category: category !== null && category !== void 0 && category.length ? category : null\n  } : {};\n  return _objectSpread({\n    priceThresholdLow: minPrice,\n    priceThresholdHigh: maxPrice,\n    priceSort: priceSort === 'recommended' ? null : priceSort,\n    keyWords: keyWords !== null && keyWords !== void 0 && keyWords.length ? keyWords : null,\n    brands: brands !== null && brands !== void 0 && brands.length ? brands : null,\n    saleThreshold: parseInt(saleThreshold)\n  }, searchSpecificFilters);\n}\nexport function getNumberOfFiltersSelected(filters) {\n  return Object.keys(filters).filter(key => {\n    const filterValue = filters[key];\n    return !!filterValue && filterValue !== 'recommended';\n  }).length;\n} // TODO: this helper is not fully \"white labeled\" given we are looking at the first item in the \"subNav\"\n// array. For different \"labels\", this will have to be rewritten\n\nexport function getCategoryFilters(section, categoryData) {\n  if (!categoryData) return [];\n\n  if (section) {\n    var _sectionData$subNav$;\n\n    const sectionData = categoryData.find(sec => sec.title === section);\n    return (sectionData === null || sectionData === void 0 ? void 0 : (_sectionData$subNav$ = sectionData.subNav[0]) === null || _sectionData$subNav$ === void 0 ? void 0 : _sectionData$subNav$.subNavItems.map(item => item.title)) || [];\n  } else {\n    const allItems = categoryData === null || categoryData === void 0 ? void 0 : categoryData.map(sec => {\n      var _sec$subNav$;\n\n      return (sec === null || sec === void 0 ? void 0 : sec.subNav) && (sec === null || sec === void 0 ? void 0 : (_sec$subNav$ = sec.subNav[0]) === null || _sec$subNav$ === void 0 ? void 0 : _sec$subNav$.subNavItems.map(item => item.title));\n    });\n    return deDupeArray((allItems === null || allItems === void 0 ? void 0 : allItems.flat()) || []);\n  }\n}\nexport function getSectionFilters(section, categoryData) {\n  return (categoryData === null || categoryData === void 0 ? void 0 : categoryData.map(sec => sec.title)) || [];\n}\nexport function sortSelectedCheckboxes(fullList, selectedList) {\n  return fullList.sort(item => {\n    if (selectedList.includes(urlCase(item))) {\n      return -1;\n    }\n  });\n}\nexport function isSearch(router) {\n  return router.pathname.includes(SEARCH_PATH);\n}","map":{"version":3,"sources":["/Users/justincoulston/Desktop/affilaite-core-mono/packages/affiliate-app/components/modules/Filters/helper.js"],"names":["deDupeArray","urlCase","SEARCH_PATH","addUrlPart","name","value","partsArray","parts","filter","item","includes","push","addExistingUrlParts","productUrl","productUrlParams","query","search","replace","split","createUrlFilters","priceSort","priceThresholdLow","priceThresholdHigh","keyWords","saleThreshold","brands","section","category","isSearchPage","origin","window","location","URL","productUrlPath","pathname","queryJoiner","urlParts","length","join","parseInt","filterPath","history","replaceState","normalizeFilters","priceThreshold","scaler","hasTouchedSlider","min","max","isMinSetting","isMaxSetting","minPrice","maxPrice","searchSpecificFilters","getNumberOfFiltersSelected","filters","Object","keys","key","filterValue","getCategoryFilters","categoryData","sectionData","find","sec","title","subNav","subNavItems","map","allItems","flat","getSectionFilters","sortSelectedCheckboxes","fullList","selectedList","sort","isSearch","router"],"mappings":"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","sourcesContent":["//@flow\nimport { type NormalizeFiltersInput, type NormalizeFiltersOutput } from './types';\nimport { type NavigationData } from '@types/navigationData';\nimport { type Router } from '@types/next';\nimport { deDupeArray, urlCase } from '@helpers/common';\nimport { SEARCH_PATH } from '@constants';\n\nexport function addUrlPart(\n  name: string,\n  value: string | number,\n  partsArray: Array<string>\n): Array<string> {\n  // remove any existing params for a given name to be overwritten\n  const parts = partsArray.filter((item) => item && !item.includes(name));\n  parts.push(`${name}=${value}`);\n  return parts;\n}\n\nexport function addExistingUrlParts(productUrl: string, productUrlParams: Object): Array<string> {\n  if (!productUrl) return [];\n  const query = productUrlParams?.search;\n  return query?.replace(/^\\?/, '').split('&') || [];\n}\n\nexport function createUrlFilters(\n  {\n    priceSort,\n    priceThresholdLow,\n    priceThresholdHigh,\n    keyWords,\n    saleThreshold,\n    brands,\n    section,\n    category,\n  }: NormalizeFiltersOutput,\n  productUrl: string,\n  isSearchPage: boolean\n): void {\n  const origin = window.location.origin;\n  const productUrlParams = new URL(`${origin}${productUrl}`);\n  const productUrlPath = productUrlParams.pathname;\n  const queryJoiner = isSearchPage ? '?' : '';\n  let urlParts = addExistingUrlParts(productUrl, productUrlParams);\n\n  if (priceSort) {\n    urlParts = addUrlPart('price-sort', priceSort, urlParts);\n  }\n\n  if (priceThresholdLow) {\n    urlParts = addUrlPart('price-threshold-low', priceThresholdLow, urlParts);\n  }\n\n  if (priceThresholdHigh) {\n    urlParts = addUrlPart('price-threshold-high', priceThresholdHigh, urlParts);\n  }\n\n  if (keyWords?.length) {\n    urlParts = addUrlPart('key-words', keyWords.join(','), urlParts);\n  }\n\n  if (brands?.length) {\n    urlParts = addUrlPart('brands', brands.join(','), urlParts);\n  }\n\n  if (saleThreshold && parseInt(saleThreshold)) {\n    urlParts = addUrlPart('sale-threshold', saleThreshold, urlParts);\n  }\n\n  if (category?.length) {\n    urlParts = addUrlPart('category', category.join(','), urlParts);\n  }\n\n  if (section) {\n    urlParts = addUrlPart('section', section, urlParts);\n  }\n\n  const filterPath = urlParts.length ? `${urlParts.join('&')}` : '';\n  window.history.replaceState({}, null, `${productUrlPath}${queryJoiner}${filterPath}`);\n}\n\nexport function normalizeFilters(\n  {\n    priceSort,\n    priceThreshold,\n    keyWords,\n    saleThreshold,\n    scaler,\n    hasTouchedSlider,\n    brands,\n    section,\n    category,\n  }: NormalizeFiltersInput,\n  isSearchPage: boolean\n): NormalizeFiltersOutput {\n  const [min, max] = priceThreshold;\n  const isMinSetting = min === 0;\n  const isMaxSetting = max === 100;\n  const minPrice = hasTouchedSlider && !isMinSetting ? min * scaler : null;\n  const maxPrice = hasTouchedSlider && !isMaxSetting ? max * scaler : null;\n  const searchSpecificFilters = isSearchPage\n    ? { section, category: category?.length ? category : null }\n    : {};\n\n  return {\n    priceThresholdLow: minPrice,\n    priceThresholdHigh: maxPrice,\n    priceSort: priceSort === 'recommended' ? null : priceSort,\n    keyWords: keyWords?.length ? keyWords : null,\n    brands: brands?.length ? brands : null,\n    saleThreshold: parseInt(saleThreshold),\n    ...searchSpecificFilters,\n  };\n}\n\nexport function getNumberOfFiltersSelected(filters: NormalizeFiltersOutput): number {\n  return Object.keys(filters).filter((key) => {\n    const filterValue = filters[key];\n    return !!filterValue && filterValue !== 'recommended';\n  }).length;\n}\n\n// TODO: this helper is not fully \"white labeled\" given we are looking at the first item in the \"subNav\"\n// array. For different \"labels\", this will have to be rewritten\nexport function getCategoryFilters(section: string, categoryData: NavigationData): Array<string> {\n  if (!categoryData) return [];\n  if (section) {\n    const sectionData = categoryData.find((sec) => sec.title === section);\n    return sectionData?.subNav[0]?.subNavItems.map((item) => item.title) || [];\n  } else {\n    const allItems = categoryData?.map(\n      (sec) => sec?.subNav && sec?.subNav[0]?.subNavItems.map((item) => item.title)\n    );\n    return deDupeArray(allItems?.flat() || []);\n  }\n}\n\nexport function getSectionFilters(section: string, categoryData: NavigationData): Array<string> {\n  return categoryData?.map((sec) => sec.title) || [];\n}\n\nexport function sortSelectedCheckboxes(\n  fullList: Array<string>,\n  selectedList: Array<string>\n): Array<string> {\n  return fullList.sort((item) => {\n    if (selectedList.includes(urlCase(item))) {\n      return -1;\n    }\n  });\n}\n\nexport function isSearch(router: Router): boolean {\n  return router.pathname.includes(SEARCH_PATH);\n}\n"]},"metadata":{},"sourceType":"module"}